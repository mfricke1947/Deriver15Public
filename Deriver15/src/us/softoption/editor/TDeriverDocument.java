

/*
 The deriver document is both data and an intermediary between the three data panes (the journal,
 the proof, and the drawing).


 The deriver document has all the data (conceptually a file). There is a browser that
 looks at the data. One browser can change data from one document to another document, or you can
 have several browsers each with their own data


 Feb 06 Adding a fourth data panel, for Trees


 */


/*
Copyright (C) 2015 Martin Frické (mfricke@email.arizona.edu https://softoption.us mfricke@softoption.us mfricke1947@gmail.com)

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation 
files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, 
modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the 
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE 
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR 
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

package us.softoption.editor;


import static us.softoption.infrastructure.Symbols.chBlank;
import static us.softoption.infrastructure.Symbols.chComma;
import static us.softoption.infrastructure.Symbols.chDoubleArrow;
import static us.softoption.infrastructure.Symbols.chImplic;
import static us.softoption.infrastructure.Symbols.chInsertMarker;
import static us.softoption.infrastructure.Symbols.chLambda;
import static us.softoption.infrastructure.Symbols.chModalNecessary;
import static us.softoption.infrastructure.Symbols.chModalPossible;
import static us.softoption.infrastructure.Symbols.setTheorySymbols;
import static us.softoption.infrastructure.Symbols.strCR;
import static us.softoption.infrastructure.Symbols.strLSqBracket;
import static us.softoption.infrastructure.Symbols.strNull;
import static us.softoption.infrastructure.Symbols.strRSqBracket;

import java.awt.Color;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Iterator;

import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JTextArea;

import jscheme.InputPort;
import jscheme.SchemeUtils;
import us.softoption.games.TGamesQuiz;
import us.softoption.games.TPredGamesQuiz;
import us.softoption.games.TProofQuiz;
import us.softoption.games.TProofQuiz2;
import us.softoption.games.TRandomProof;
import us.softoption.games.TRandomProofPanel;
import us.softoption.games.TTreeQuiz;
import us.softoption.infrastructure.TConstants;
import us.softoption.infrastructure.TScheme;
import us.softoption.interpretation.TShapePanel;
import us.softoption.parser.TFormula;
import us.softoption.parser.TParser;
import us.softoption.proofs.TLambda;
import us.softoption.proofs.TMyProofPanel;
import us.softoption.proofs.TProofPanel;
import us.softoption.resolution.TResolutionPanel;
import us.softoption.tree.TTreePanel;

public class TDeriverDocument{


//  public TDeriverApplication fApplication=null;


  private TJournal fJournal;       //interface to receive writing  (sometimes a Browser sometimes an applet)
                                   // can be null in some cases, so check for it.




 // public TBrowser fBrowser=null;  // can run without this, so long as there is something to write to


  public TProofPanel fProofPanel;
  public TShapePanel fShapePanel;

  public TTreePanel fTreePanel;  //experimental
  public TLambda fLambdaPanel;
  public TResolutionPanel fResolutionPanel;

  protected TParser fParser;
  public String fParserName="";        //default, gets shown in title bar of browser, subclasses change
  public ArrayList fValuation=new ArrayList();

  public ArrayList fInterpretationList=new ArrayList();

  /*
   fInterpretationList: TList; {list of formulas generated by open}
{                                                                  node in statisfaiable}

  */

  public TLispJava fBridge;
  public TEnglishToLogic fEToL = new TEnglishToLogic(); //Aug 10 06, moved from application so all documenets have their own context

  private boolean fDirty = false;  // changes not saved

  public static boolean kHIGHLIGHT=true;
  public static boolean kTO_MARKER=true;

  public static int fVersion=1;    //file format version

  public String fBasicPalette= "";

  public String fDefaultPaletteText="";

  TRandomProof fRandomProof= new TRandomProof(); // for quizzes, for subclasses to override

  boolean fUseIdentity=false;    // for getting more menu items independently of Preferences


  public TDeriverDocument(){
    initializeParser();

initializeProofPanel();

initializePalettes();

fShapePanel = new TShapePanel(this,"Shape Frame", 640, 480,
                                           Color.white);

fTreePanel = new TTreePanel(this);

fLambdaPanel = new TLambda(this);

fResolutionPanel = new TResolutionPanel(this);

fBridge= new TLispJava();
  }



  //public TDeriverDocument(TDeriverApplication itsApplication/*, TJournal itsJournal*/){

  // this();

      //   fApplication=itsApplication;


    /*at the moment the JournalPane is just text (not subclassed) so, for
    the present it is part of the Browser. The main edit menu (and other menus)
    in the Browser, refer to the journalPane. So it is natural to leave it there,*/


 // fBrowser= new TBrowser(this,itsApplication);
//  fJournal=new TBrowser(this,itsApplication); /*fBrowser;*/
 // }

  public TDeriverDocument(TJournal itsJournal){   // when it is running without a Browser, eg in an applet

 this();

    //   fApplication=itsApplication;

  /*at the moment the JournalPane is just text (not subclassed) so, for
  the present it is part of the Browser. The main edit menu (and other menus)
  in the Browser, refer to the journalPane. So it is natural to leave it there,*/

//fBrowser= null;
fJournal=itsJournal;
}

  public TDeriverDocument(TJournal itsJournal,boolean wantsIdentity){
    fUseIdentity=wantsIdentity;

    initializeParser();

initializeProofPanel(fUseIdentity);

initializePalettes();

fShapePanel = new TShapePanel(this,"Shape Frame", 640, 480,
                              Color.white,fUseIdentity);

fTreePanel = new TTreePanel(this);

fLambdaPanel = new TLambda(this);

fBridge= new TLispJava();

fJournal=itsJournal;
}



  void initializePalettes(){  // for override

   fBasicPalette= " \u223C  "+fParser.renderAnd()+"  \u2228  \u2283  \u2261  \u2200  \u2203  \u2234 ";

   fDefaultPaletteText=strCR+   /* F therefore F and G not  and  or  implic  bi  all  exists  therefore   */

                          "F \u2234 F "+fParser.renderAnd()+" G"+

                          " \u223C  "+fParser.renderAnd()+"  \u2228  \u2283  \u2261  \u2200  \u2203  \u2234 " +

                          (TPreferences.fModal?(chModalNecessary+" "+chModalPossible+" "):"")+
                          (TPreferences.fLambda?(chLambda+" " +chDoubleArrow):"")+
                          (TPreferences.fSetTheory?(" " +setTheorySymbols):"")+
                          strCR+
                          strCR+

                     " Rxy[a/x,b/y] (\u2200x)(Fx \u2283 Gx)"
;


  }

  public void initializeProofPanel(){
 /*   if (TPreferences.fRewriteRules)
    fProofPanel= new TRewrite(this);
else */
    fProofPanel= new TMyProofPanel(this);

  }

  public void initializeProofPanel(boolean wantsIdentity){

    fProofPanel= new TMyProofPanel(this,wantsIdentity);

  }



  public void initializeParser(){

     fParser= new TParser(); // default

  }

  public void setDirty(boolean dirty){
    fDirty=dirty;
  }

  public boolean isDirty(){
   return
       fDirty;
 }

 public TJournal getJournal(){
  return
      fJournal;
}

public void setJournal(TJournal itsJournal){
  fJournal=itsJournal;

}

public void startLambdaProof(String inputStr){
  fLambdaPanel.startLambdaProof(inputStr);
}

public void startProof(String inputStr){
  fProofPanel.startProof(inputStr);
}

public void startResolution(String inputStr){
  fResolutionPanel.startResolution(inputStr);
	}

public void startTree(String inputStr){
  fTreePanel.startTree(inputStr);
}

/************/

public JMenu supplyExamsSubMenu(){        // the different document types eg Copi want different ones of these
  JMenu exams= new JMenu();

  exams.add(new MidTermQ6());
  exams.add(new MidTermQ78());
  exams.add(new FinalQ6());
  exams.add(new FinalQ78());


  return
      exams;

}

public JMenu supplyQuizzesSubMenu(){        // the different document types eg Copi want different ones of these
  JMenu quizzes= new JMenu();


  quizzes.add(new Quiz2());
  quizzes.add(new Quiz3());
  quizzes.add(new Quiz4());
  quizzes.add(new Quiz5());
  quizzes.add(new Quiz6());
  quizzes.add(new Quiz7());
  quizzes.add(new Quiz8());
  quizzes.add(new BonusQuiz());
  quizzes.add(new TreeQuiz(this));
  return
      quizzes;

}

public boolean getUseIdentity(){
    return
        fUseIdentity;
  }

public void setUseIdentity(boolean use){
          fUseIdentity=use;
  }

class MidTermQ6 extends JMenuItem{

      public MidTermQ6(){
        setText("Mid-term Q6 [Prop]");
        addActionListener(new ActionListener() {
          public void actionPerformed(ActionEvent e) {

     if (TGamesQuiz.fNumOpen==0){

       TGamesQuiz quiz = new TGamesQuiz(fParser,
                                        "Mid-term Question 6",
           0,0,
           5,75,
           5,75,
           3,360,
           3,360);

       quiz.removeConnectiveTab();


       quiz.setVisible(true);
     }
  }

        });
      }
     }

     class MidTermQ78 extends JMenuItem{

           public MidTermQ78(){
             setText("Mid-term Q7,8 [Prop]");
             addActionListener(new ActionListener() {
               public void actionPerformed(ActionEvent e) {

                 if (TProofQuiz2.fNumOpen == 0) {

                   TProofQuiz2 quiz = new TProofQuiz2(fProofPanel,
                                                      fRandomProof,
                       "Mid-term Question 6,7");
                   quiz.setVisible(true);
                 }
               }

             });
           }
     }

     class FinalQ6 extends JMenuItem{

           public FinalQ6(){
             setText("Final Q6 [Pred]");
             addActionListener(new ActionListener() {
               public void actionPerformed(ActionEvent e) {

      if (TProofQuiz.fNumOpen==0){

       int [] prooftypes= {TRandomProofPanel.TwelveLineProp,                 //NEED TO BE DIFFERENT
                                          TRandomProofPanel.TenLinePred,
                                          TRandomProofPanel.TenLinePred};

       JTextArea text= new JTextArea(strCR
                                              + "Work through the Tabs to Finish. [These are 8-12 line derivations.]"
                                              + strCR
                                              + strCR
                                              + "For the Final, you need do just TWO of these THREE"

                                              + strCR
                                              + strCR
                                              + "Proof1: a propositional derivation which might use any of the propositional rules."
                                              + strCR
                                              + "Proof2: a predicate derivation which might use any of the rules."
                                              + strCR
                                              + "Proof3: a predicate derivation which might use any of the rules."

                                              + strCR+ strCR
                                              + ""
                                              + strCR
                                              + "When you reach Finish, submit if you are satisfied. Otherwise close and open to start over."
                                              + strCR
                                      );




       TProofQuiz quiz = new TProofQuiz(/*fDeriverDocument.*/fProofPanel,//this,
           fRandomProof,
                                        "Final Q7,8",
                                        prooftypes,
                                        text
    );
       quiz.setVisible(true);
     }

               }



             });
           }
     }

     class FinalQ78 extends JMenuItem{

            public FinalQ78(){
              setText("Final Q7,8 [Pred]");
              addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {

      if (TPredGamesQuiz.fNumOpen==0){

       TPredGamesQuiz quiz = new TPredGamesQuiz(fParser,
           "Final Q6",
           0,0,
           5,300,
           2,300,
           1,300,
           1,300,
           1,300);

     quiz.removeConnectiveTab();

       quiz.setVisible(true);
     }


    }


              });
            }
     }


class Quiz2 extends JMenuItem{

      public Quiz2(){
        setText("Quiz 2 [Prop]");
        addActionListener(new ActionListener() {
          public void actionPerformed(ActionEvent e) {

            if (TGamesQuiz.fNumOpen == 0) {
              String dummy=TPreferences.getUser();
              TGamesQuiz quiz = new TGamesQuiz(fParser,
                                               "Quiz 2",
                  5, 40,
                  5, 150, /*10*/
                  5, 150, /*10*/
                  3, 600, /*5*/
                  2, 600); /*5*/
              quiz.setVisible(true);
            }
          }
        });
      }
     }

     class Quiz3 extends JMenuItem{

           public Quiz3() {
             setText("Quiz 3 [Prop]");
             addActionListener(new ActionListener() {
               public void actionPerformed(ActionEvent e) {

                 if (TProofQuiz.fNumOpen == 0) {

                   int[] prooftypes = {
                       TRandomProofPanel.SimpleAndIENegEOrI,
                       TRandomProofPanel.SimpleAndIENegEOrI,
                       TRandomProofPanel.SimpleAndIENegEOrI,
                       TRandomProofPanel.AndIENegEOrI,
                       TRandomProofPanel.AndIENegEOrI};

                   JTextArea text = new JTextArea(strCR
                                                  + "Work through the Tabs to Finish. [These are elementary/intermediate level derivations.]"
                                                  + strCR
                                                  + strCR
                                                  +
                                                  "Proof1: a simple derivation using \u223CE "+fParser.renderAnd()+"I "+fParser.renderAnd()+"E \u2228I ."
                                                  + strCR
                                                  +
                                                  "Proof2: a simple derivation using \u223CE "+fParser.renderAnd()+"I "+fParser.renderAnd()+"E \u2228I ."
                                                  + strCR
                                                  +
                                                  "Proof3: a simple derivation using \u223CE "+fParser.renderAnd()+"I "+fParser.renderAnd()+"E \u2228I ."
                                                  + strCR
                                                  +
                                                  "Proof4: an intermediate derivation using \u223CE "+fParser.renderAnd()+"I "+fParser.renderAnd()+"E \u2228I ."
                                                  + strCR
                                                  +
                                                  "Proof5: an intermediate derivation using \u223CE "+fParser.renderAnd()+"I "+fParser.renderAnd()+"E \u2228I  ."
                                                  + strCR + strCR
                                                  + ""
                                                  + strCR
                                                  + "When you reach Finish, submit if you are satisfied. Otherwise close and open to start over."
                                                  + strCR
                       );

                   TProofQuiz quiz = new TProofQuiz(/*fDeriverDocument.*/fProofPanel,//TBrowser.this,
                       fRandomProof,
                                                    "Quiz 3",
                                                    prooftypes,
                                                    text
                       );
                   quiz.setVisible(true);
                 }
               }

             });
           }
         }


         class Quiz4 extends JMenuItem{


                public Quiz4() {
                  setText("Quiz 4 [Prop]");
                  addActionListener(new ActionListener() {
                    public void actionPerformed(ActionEvent e) {



              if (TProofQuiz.fNumOpen==0){

                int [] prooftypes= {TRandomProofPanel.SimpleImplicEEquivE,
                                                 TRandomProofPanel.SimpleImplicEEquivE,
                                                 TRandomProofPanel.SimpleImplicEEquivE,
                                                 TRandomProofPanel.ImplicEEquivE,
                                                 TRandomProofPanel.ImplicEEquivE};


                JTextArea text= new JTextArea(strCR
                                                       + "Work through the Tabs to Finish. [These are elementary/intermediate level derivations.]"
                                                       + strCR
                                                       + strCR
                                                       + "Proof1: a simple derivation using \u2283E \u2261E  ."
                                                       + strCR
                                                       + "Proof2: a simple derivation using \u2283E \u2261E  ."
                                                       + strCR
                                                       + "Proof3: a simple derivation using \u2283E \u2261E  ."
                                                       + strCR
                                                       + "Proof4: an intermediate derivation using \u2283E \u2261E  ."
                                                       + strCR
                                                       + "Proof5: an intermediate derivation using \u2283E \u2261E   ."
                                                       + strCR+ strCR
                                                       + ""
                                                       + strCR
                                                       + "When you reach Finish, submit if you are satisfied. Otherwise close and open to start over."
                                                       + strCR
                                               );






                TProofQuiz quiz = new TProofQuiz(/*fDeriverDocument.*/fProofPanel,//this,
                    fRandomProof,
                                                 "Quiz 4",
                                                 prooftypes,
                                                 text
             );
                quiz.setVisible(true);
              }
           }
         ;
                  });
                }
     }

     class Quiz5 extends JMenuItem{


      public Quiz5(){
        setText("Quiz 5 [Prop]");
        addActionListener(new ActionListener() {
          public void actionPerformed(ActionEvent e) {

            if (TProofQuiz.fNumOpen==0){

            int [] prooftypes= {TRandomProofPanel.ImplicI,
                                             TRandomProofPanel.ImplicI,
                                             TRandomProofPanel.ImplicI,
                                             TRandomProofPanel.ImplicI,
                                             TRandomProofPanel.ImplicI};


            JTextArea text= new JTextArea(strCR
                                                   + "Work through the Tabs to Finish. [These are elementary/intermediate level derivations.]"
                                                   + strCR
                                                   + strCR
                                                   + "Proof1: a simple derivation using \u2283 I ."
                                                   + strCR
                                                   + "Proof2: a simple derivation using \u2283 I  ."
                                                   + strCR
                                                   + "Proof3: a simple derivation using \u2283 I  ."
                                                   + strCR
                                                   + "Proof4: a simple derivation using \u2283 I  ."
                                                   + strCR
                                                   + "Proof5: a simple derivation using \u2283 I   ."
                                                   + strCR+ strCR
                                                   + ""
                                                   + strCR
                                                   + "When you reach Finish, submit if you are satisfied. Otherwise close and open to start over."
                                                   + strCR
                                           );




            String dummy=TPreferences.getUser();

            TProofQuiz quiz = new TProofQuiz(/*fDeriverDocument.*/fProofPanel,//TBrowser.this,
                fRandomProof,
                                             "Quiz 5",
                                             prooftypes,
                                             text
         );
            quiz.setVisible(true);
          }

          };
        });
      }



     }

     class Quiz6 extends JMenuItem{


            public Quiz6(){
              setText("Quiz 6 [Prop]");
              addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {

                  if (TProofQuiz.fNumOpen==0){

                  int [] prooftypes= {TRandomProofPanel.SimpleNegI,
                                                   TRandomProofPanel.SimpleNegI,
                                                   TRandomProofPanel.SimpleNegI,
                                                   TRandomProofPanel.NegI,
                                                   TRandomProofPanel.NegI};


                  JTextArea text= new JTextArea(strCR
                                                         + "Work through the Tabs to Finish. [These are elementary/intermediate level derivations.]"
                                                         + strCR
                                                         + strCR
                                                         + "Proof1: a simple derivation using \u223C  I ."
                                                         + strCR
                                                         + "Proof2: a simple derivation using \u223C  I  ."
                                                         + strCR
                                                         + "Proof3: a simple derivation using \u223C  I  ."
                                                         + strCR
                                                         + "Proof4: a harder derivation using \u223C  I  ."
                                                         + strCR
                                                         + "Proof5: a harder derivation using \u223C  I   ."
                                                         + strCR+ strCR
                                                         + ""
                                                         + strCR
                                                         + "When you reach Finish, submit if you are satisfied. Otherwise close and open to start over."
                                                         + strCR
                                                 );


                       String dummy=TPreferences.getUser();
                                             TProofQuiz quiz = new TProofQuiz(/*fDeriverDocument.*/fProofPanel,//TBrowser.this,
                                                 fRandomProof,
                                                   "Quiz 6",
                                                   prooftypes,
                                                   text
               );
                  quiz.setVisible(true);
                }

                };
              });
            }
     }


     class Quiz7 extends JMenuItem{


               public Quiz7(){
                 setText("Quiz 7 [Pred]");
                 addActionListener(new ActionListener() {
                   public void actionPerformed(ActionEvent e) {

                     if (TPredGamesQuiz.fNumOpen==0){
                       String dummy=TPreferences.getUser();

     TPredGamesQuiz quiz = new TPredGamesQuiz(fParser,//fDeriverDocument.getParser(),
                                              "Quiz 7",
         5,40,
         5,300,
         2,300,
         1,300,
         1,300,
         1,300);
     quiz.setVisible(true);
   }


                   };
                 });
               }
    }

    class Quiz8 extends JMenuItem{


                public Quiz8(){
                  setText("Quiz 8 [Pred]");
                  addActionListener(new ActionListener() {
                    public void actionPerformed(ActionEvent e) {



                      if (TProofQuiz.fNumOpen==0){

       int [] prooftypes= {TRandomProofPanel.PredNoQuant,
                                        TRandomProofPanel.SimpleUI,
                                        TRandomProofPanel.SimpleUG,
                                        TRandomProofPanel.SimpleEG,
                                        TRandomProofPanel.SimpleEI};
       JTextArea text= new JTextArea(strCR
                                            + "Work through the Tabs to Finish. [Proof 1 is intermediate level, 2-5 are elementary.]"
                                            + strCR
                                            + strCR
                                            + "Proof 1: a derivation in predicate calculus, without quantifiers."
                                            + strCR
                                            + "Proof 2: a derivation using UI."
                                            + strCR
                                            + "Proof 3: a derivation using UG."
                                            + strCR
                                            + "Proof 4: a derivation using EG."
                                            + strCR
                                            + "Proof 5: a derivation using EI."
                                            + strCR+ strCR
                                            + ""
                                            + strCR
                                            + "When you reach Finish, submit if you are satisfied. Otherwise close and open to start over."
                                            + strCR
                                    );
                                String dummy=TPreferences.getUser();

      TProofQuiz quiz = new TProofQuiz(/*fDeriverDocument.*/fProofPanel,//TBrowser.this,
          fRandomProof,
                                       "Quiz 8",
                                      prooftypes,
                                      text
  );
      quiz.setVisible(true);
    }



                    };
                  });
                }
     }

     class BonusQuiz extends JMenuItem{


                 public BonusQuiz(){
                   setText("Bonus Quiz [Pred]");
                   addActionListener(new ActionListener() {
                     public void actionPerformed(ActionEvent e) {



                       if (TProofQuiz.fNumOpen==0){

        int [] prooftypes= {TRandomProofPanel.AnyAnyLevel,
                                         TRandomProofPanel.AnyAnyLevel,
                                         TRandomProofPanel.AnyAnyLevel,
                                         TRandomProofPanel.AnyAnyLevel,
                                         TRandomProofPanel.AnyAnyLevel};
        JTextArea text= new JTextArea(strCR
                                             + "Work through the Tabs to Finish. [You may use rewrite rules.]"
                                             + strCR
                                             + strCR
                                             + "Proof 1: a derivation of any type and difficulty."
                                             + strCR
                                             + "Proof 2: a derivation of any type and difficulty."
                                             + strCR
                                             + "Proof 3: a derivation of any type and difficulty."
                                             + strCR
                                             + "Proof 4: a derivation of any type and difficulty."
                                             + strCR
                                             + "Proof 5: a derivation of any type and difficulty."
                                             + strCR+ strCR
                                             + ""
                                             + strCR
                                             + "When you reach Finish, submit if you are satisfied. Otherwise close and open to start over."
                                             + strCR
                                     );
                                 String dummy=TPreferences.getUser();

       TProofQuiz quiz = new TProofQuiz(/*fDeriverDocument.*/fProofPanel,//TBrowser.this,
           fRandomProof,
                                        "Bonus Quiz",
                                       prooftypes,
                                       text
   );
       quiz.setVisible(true);
     }
                     };
                   });
                 }
    }





    class TreeQuiz extends JMenuItem{

          public TreeQuiz(final TDeriverDocument aDocument) {
            setText("Tree Quiz");
            addActionListener(new ActionListener() {
              public void actionPerformed(ActionEvent e) {

                if (TTreeQuiz.fNumOpen == 0) {



                  TTreeQuiz quiz = new TTreeQuiz(fParser, aDocument);
                  quiz.setVisible(true);
                }
              }

            });
          }
         }

/****************************/


void clearProofAndDrawing(){
  fProofPanel.dismantleProof();
  fProofPanel.initProof();
  fProofPanel.createBlankStart();

  fShapePanel.resetToEmpty();
  
  fTreePanel.resetToEmpty();
}


  public void writeToJournal(String message, boolean highlight,boolean toMarker){
    if (fJournal==null)
      System.out.println("writeToJournal() called with null Journal. With applets might not be an error.");
    else
      fJournal.writeToJournal(message, highlight, toMarker);
  }


public void constructDrawing(ArrayList interpretationList){

    fShapePanel.constructDrawing(interpretationList);
  }


public void writeInterpretation(){

  /*This should be pretty similar to drawing the Interpretation Board*/


 String outputStr = fShapePanel.getSemantics().interpretationToString();

 /*fJournal.*/writeToJournal(outputStr, kHIGHLIGHT, !kTO_MARKER);

}



/*

   procedure TDeriverDocument.WriteInterpretation; {changes needed}

    var
     i, lengthofStr: integer;
     tempStr: str255;
     charIndex: CHAR;

   begin
    if InterpretationChanged then
     ; {UPDATES}

    tempStr := fCurrentUniverse;
    lengthofStr := length(tempStr);
    if lengthofStr > 110 then
     lengthofStr := 110; {not out of range}
    while lengthofStr > 1 do
     begin
      insert(',', tempStr, lengthofStr);
      lengthofStr := lengthofStr - 1;
     end;

    tempStr := concat(gCR, 'Universe= { ', tempStr, ' }', gCR);

    WriteToJournal(tempStr, FALSE, FALSE);



    for charIndex := 'A' to 'Z' do
     begin

      tempStr := fCurrentProperties[charIndex];
      lengthofStr := length(tempStr);
      if lengthofStr > 0 then
       begin
        if lengthofStr > 110 then
         lengthofStr := 110; {not out of range}
        while lengthofStr > 1 do
         begin
         insert(',', tempStr, lengthofStr);
         lengthofStr := lengthofStr - 1;
         end;

        tempStr := concat(charIndex, '= { ', tempStr, ' }', gCR);

        WriteToJournal(tempStr, FALSE, FALSE);

       end;
     end;

    for charIndex := 'A' to 'Z' do
     begin

      tempStr := fCurrentRelations[charIndex];
      lengthofStr := length(tempStr) - 1;
      if lengthofStr > 0 then
       begin
        if lengthofStr > 110 then
         lengthofStr := 110; {not out of range}

        while lengthofStr > 1 do
         begin
         insert('>,<', tempStr, lengthofStr);
         lengthofStr := lengthofStr - 2;
         end;

        if length(tempStr) > 1 then
         tempStr := concat('<', tempStr, '>');

        tempStr := concat(charIndex, '�= { ', tempStr, ' }', gCR);

        WriteToJournal(tempStr, FALSE, FALSE);
       end;
     end;

    for charIndex := 'a' to 'z' do
     begin

      tempStr := fCurrentFunctions[charIndex];
      lengthofStr := length(tempStr) - 1;
      if lengthofStr > 0 then
       begin
        if lengthofStr > 110 then
         lengthofStr := 110; {not out of range}

        while lengthofStr > 1 do
         begin
         insert('>,<', tempStr, lengthofStr);
         lengthofStr := lengthofStr - 2;
         end;

        if length(tempStr) > 1 then
         tempStr := concat('<', tempStr, '>');

        tempStr := concat(charIndex, '�= { ', tempStr, ' }', gCR);

        WriteToJournal(tempStr, FALSE, FALSE);
       end;


     end;

    for charIndex := 'a' to 'z' do
     begin

      if fCurrentIdentities[charIndex] <> chBlank then
       begin

        tempStr := StrOfChar(fCurrentIdentities[charIndex]);

        tempStr := concat(charIndex, '= { ', tempStr, ' }', gCR);

        WriteToJournal(tempStr, FALSE, FALSE);
       end;


     end;



   end;



*/

void writeTruePropositions(){

  String outputStr = fShapePanel.getSemantics().propositionsToString();

  /*fJournal.*/writeToJournal(outputStr, kHIGHLIGHT, !kTO_MARKER);


}


/*

 procedure TDeriverDocument.WriteTruePropositions;
   var
    lengthofStr: integer;
    tempStr: str255;
    charIndex: CHAR;
  begin
   tempStr := strNull;

   for charIndex := 'A' to 'Z' do
    if fCurrentPropositions[charIndex] then
     tempStr := concat(tempStr, charIndex);

   lengthofStr := length(tempStr);
   if lengthofStr > 0 then
    begin
     while lengthofStr > 1 do
      begin
       insert(',', tempStr, lengthofStr);
       lengthofStr := lengthofStr - 1;
      end;

     tempStr := concat('True Atomic Propositions = { ', tempStr, ' }', gCR);

     WriteToJournal(tempStr, kHIGHLIGHT, not kTConstants.TO_MARKER);
    end
   else
    begin
     tempStr := concat('All atomic propositions are assigned false.');

     WriteToJournal(tempStr, kHIGHLIGHT, not kTConstants.TO_MARKER);
    end;
  end;


*/

public void clearValuation(){
    fValuation=new ArrayList();
}


String writeShortValuation(){
  int linelength=80;
   String outputStr="";

   if (fValuation.size()!=0){

     outputStr = "" + strLSqBracket;

     Iterator iter=fValuation.iterator();
     TFormula entry;
     boolean first=true;

     while (iter.hasNext()){

       if(!first)
         outputStr = outputStr + chComma;
       else
         first=false;

       entry=(TFormula)iter.next();

       outputStr = outputStr+entry.fInfo;

       if (outputStr.length() > linelength){    //never going to happen
         outputStr=outputStr+ strCR;
         linelength+=80;
       }
     }
     outputStr = outputStr+ strRSqBracket;
   }

return
       outputStr;
}


public void writeValuation(){
   String outputStr=writeShortValuation();

   if (!outputStr.equals("")){

     outputStr = strCR
                 + "Current valuation is "
                 + outputStr
                 + strCR;
   }
   else{

     outputStr = strCR
                 + "There is no current valuation."
                 + strCR;
   }
    /* fJournal.*/writeToJournal(outputStr, kHIGHLIGHT, !kTO_MARKER);
}


/*

    procedure TDeriverDocument.WriteValuation;

    const
     linelength = 80;

    var
     item: TObject;
     root: TFormula;

    procedure WriteInfo (item: TObject); {stuff to go in here}

     var
      aFormula: TFormula; {watch size}

    begin
     if item <> nil then
      begin
       if item <> fvaluation.First then
        gOutputStr := concat(gOutputStr, chComma);
       root := TFormula(item);
       gOutputStr := concat(gOutputStr, root.fInfo);
       if length(gOutputStr) > linelength then
        begin
         gOutputStr := concat(gOutputStr, gCR);

         WriteToJournal(gOutputStr, FALSE, FALSE);

         gOutputStr := '';

        end;
      end;
    end;

   begin

    if fvaluation.fSize <> 0 then
     begin
      gOutputStr := concat(gCR, 'Current valuation is ');
      gOutputStr := concat(gOutputStr, chLSqBracket);
      fvaluation.Each(WriteInfo);
      gOutputStr := concat(gOutputStr, chRSqBracket, gCR);

      WriteToJournal(gOutputStr, FALSE, FALSE);

     end;

   end;



  */


public TFormula truthPresuppositionsHold(TFormula root){
     //prepare checks whether the reference is ok

     TFormula valuedFormula;
     char freeCh;

  if ((fShapePanel.getSemantics().universeEmpty())/*&&(root.termsInFormula()!=null)
  This was commented out before 2015, don't know why but it is going back in
  to handle special predefineds like True and propositions*/ &&(root.termsInFormula()!=null)
		  
		  
		  
		  ){
    writeToJournal(TConstants.fErrors1, TConstants.HIGHLIGHT,
                   !TConstants.TO_MARKER);
    return
        null;
  }
  else{
    valuedFormula = root.copyFormula(); //probably don't need a copy here
    valuedFormula.interpretFreeVariables(fValuation);

  //  freeCh = valuedFormula.firstFreeVar();
    
    freeCh = fParser.firstFreeVar(valuedFormula);

    if (freeCh != chBlank) {
      writeToJournal(strCR +
                     "(*The free variable " +
                     freeCh +
                     " needs to be valued.*)" +
                     strCR
                     , TConstants.HIGHLIGHT, !TConstants.TO_MARKER);
      return
          null;
    }
  }
  return
        valuedFormula;
 }


 public boolean badConstants(TFormula root){  //USE THIS IN BROWSER PREPARE METHOD
   String badConstants=strNull;

   badConstants= constantsNotReferring(root);

           if ((badConstants!=strNull)&&!root.isSpecialPredefined()){

             writeToJournal(strCR +
                                             "(*You should have an object " +
                                             badConstants +
                                             " in the Universe*)" +
                                             strCR +
                                             "(*for the constant named " +
                                             badConstants +
                                             " to refer to*)" +
                                             strCR
                                             , TConstants.HIGHLIGHT, !TConstants.TO_MARKER);
             return
                 true;
           }
   else
     return
         false;
}




public void selectionTrue(TFormula root){

   //prepare checks whether the reference is ok

   TFormula valuedFormula=truthPresuppositionsHold(root);

   if (valuedFormula!=null)
   {
      if (valuedFormulaTrue(valuedFormula))
          writeToJournal(" True ", TConstants.HIGHLIGHT, !TConstants.TO_MARKER);
      else
          writeToJournal(" False ", TConstants.HIGHLIGHT, !TConstants.TO_MARKER);
    }

}



 /*

  procedure TJournalWindow.SelectionTrue;


 var
  freeCh: char;

{prepare checks whether reference is OK}

begin

 if fDeriverDocument.UniverseEmpty & not (gRoot.TermsInFormula = nil) then
  fDeriverDocument.WriteToJournal(gErrorsArray[1], TRUE, FALSE)
 else
  begin
   fDeriverDocument.InterpretFreeVariables(gRoot);
   if fDeriverDocument.FirstVarFree(gRoot, freeCh) then
    fDeriverDocument.WriteToJournal(concat(gCr, '(*The free variable ', StrOfChar(freeCh), ' needs to be valued.*)', gCr), TRUE, FALSE)

   else
    begin
     if fDeriverDocument.ValuedFormulaTrue(gRoot) then
      fDeriverDocument.WriteToJournal(concat(' True '), kTConstants.HIGHLIGHT, not kTO_MARKER)
     else
      fDeriverDocument.WriteToJournal(concat(' False '), kTConstants.HIGHLIGHT, not kTO_MARKER)
    end;
  end;
end;



 */

char firstVarFree(TFormula root){  // need to have it defined here for override with logical systems
   return
       //root.firstFreeVar();
   fParser.firstFreeVar(root);
}


/*

 function TDeriverDocument.FirstVarFree (root: TFormula; var ch: char): BOOLEAN;
 begin
  FirstVarFree := root.FirstFreeVar(ch);   (*to allow overiding for different variables*)
                                                                                  (*need to do it for Copi*)
 end;


 */



/*

   procedure TJournalWindow.SelectionTrue;


   var
    freeCh: char;

 {prepare checks whether reference is OK}

  begin

   if fDeriverDocument.UniverseEmpty & not (gRoot.TermsInFormula = nil) then
    fDeriverDocument.WriteToJournal(gErrorsArray[1], TRUE, FALSE)
   else
    begin
     fDeriverDocument.InterpretFreeVariables(gRoot);
     if fDeriverDocument.FirstVarFree(gRoot, freeCh) then
      fDeriverDocument.WriteToJournal(concat(gCr, '(*The free variable ', StrOfChar(freeCh), ' needs to be valued.*)', gCr), TRUE, FALSE)

     else
      begin
       if fDeriverDocument.ValuedFormulaTrue(gRoot) then
        fDeriverDocument.WriteToJournal(concat(' True '), kTConstants.HIGHLIGHT, not kTO_MARKER)
       else
        fDeriverDocument.WriteToJournal(concat(' False '), kTConstants.HIGHLIGHT, not kTO_MARKER)
      end;
    end;
  end;


 */


public boolean valuedFormulaTrue(TFormula root){
  TFormula valuedFormula;

  if ((fShapePanel.getSemantics().universeEmpty())&&
      (root.termsInFormula()!=null)){
     writeToJournal(TConstants.fErrors1, TConstants.HIGHLIGHT, !TConstants.TO_MARKER);
     return
        false;
  }
  else{
    valuedFormula=root.copyFormula();
    valuedFormula.interpretFreeVariables(fValuation);
    return
        formulaTrue(valuedFormula);
  }

}



/*

 function TDeriverDocument.ValuedFormulaTrue (root: TFormula): BOOLEAN;

  var
   itsTruth: BOOLEAN;
   itsMainConnective, dummy: CHAR;
   valuedFormula: TFormula;

 begin
  itsTruth := FALSE;
  if UniverseEmpty & not (gRoot.TermsInFormula = nil) then
   WriteToJournal(gErrorsArray[1], TRUE, FALSE)
  else
   begin
    valuedFormula := root.CopyFormula;
    InterpretFreeVariables(valuedFormula);
    itsTruth := FormulaTrue(valuedFormula);
    valuedFormula.DismantleFormula;
   end;
  ValuedFormulaTrue := itsTruth;
 end;




 */






public String constantsNotReferring(TFormula root){  //FIRST ONE ONLY
  /*

     this function called referenceOK in Pascal

     {The valued formulas must be OK}
     {Two possibilities here, either a constant must be in the universe, or it must be}
     {a zero-ary functor whose referent is in the universe}


  */


 String constInFormula;

 TFormula valuedFormula=root.copyFormula();

 valuedFormula.interpretFreeVariables(fValuation);

// constInFormula=valuedFormula.constantsInFormula();  Dec09
 
 constInFormula=fParser.constantsInFormula(valuedFormula);

 return
     fShapePanel.getSemantics().firstBadConstant(constInFormula);
}


/*

    function TDeriverDocument.ReferenceOK (root: TFormula; var notRefTo: CHAR): BOOLEAN;


    var
     found: BOOLEAN;
     constInFormula: str255;
     i: integer;
     charStr: string[1];
     valuedFormula: TFormula;

   begin
    found := TRUE;
    charStr := ' ';

    valuedFormula := root.CopyFormula;
    InterpretFreeVariables(valuedFormula);

    constInFormula := FormulasConstants(valuedFormula); (*valuedFormula.ConstantsInFormula; *)
    i := 1;
    while (i <= length(constInFormula)) and found do
     begin
      charStr[1] := constInFormula[i];
      if pos(charStr, fCurrentUniverse) = 0 then
       if fCurrentIdentities[charStr[1]] = chBlank then  {not a 'dual name'}
        found := FALSE;
      i := i + 1;

     end;
    notRefTo := charStr[1];
    valuedFormula.DismantleFormula;
    ReferenceOK := found;

   end;



  */








 /********************************** COMMANDS ****************************************/

 public void doCommand(String inputStr){

   fBridge.doCommand(inputStr);


 }





 /************************************************************************************/







 char valueFunctionalTerm(TFormula term){
   char value;
   char nameOfFunctor=term.getInfo().charAt(0);

   if (term.firstTerm()==null){
     value=(fShapePanel.getSemantics()).valueOfIdentity(nameOfFunctor); //zero ary functor

     if (value!=chBlank)
       return
          value;            // value of alias
     else
       return
          nameOfFunctor;    // genuine proper name
   }
   else{
     if (term.secondTerm()!=null)
       writeToJournal(TConstants.fErrors15, TConstants.HIGHLIGHT, !TConstants.TO_MARKER);

    value=(fShapePanel.getSemantics()).valueOfFunction(nameOfFunctor, valueFunctionalTerm(term.firstTerm()));
   }

   return
       value;
 }


 /*

 function TDeriverDocument.ValueFunctionalTerm (term: TFormula): CHAR;
  var
   tempCH: char;
 begin
  if term.FirstTerm = nil then
   begin
    tempCh := fCurrentIdentities[term.fInfo[1]]; {0-ary functions}
    if (tempCh = chBlank) then
     tempCh := term.fInfo[1]   (*genuine proper name*)
   end
  else
   begin
    if term.SecondTerm <> nil then
     WriteToJournal(concat(gCr, '(*The arity of a function should be no greater than 1.*)', gCr, '(*Any function of arity n, n>1, can be Curried to*)', gCr, '(*unary functions-- here higher arguments are*)', gCr, '(*just ignored.*)'), TRUE, FALSE);

    tempCh := SELF.FindFunctionValue(term.fInfo[1], SELF.ValueFunctionalTerm(term.FirstTerm));
   end;
  ValueFunctionalTerm := tempCh;

 end;

*/

boolean propositionTrue(char prop){


    return
        (fShapePanel.getSemantics()).propositionTrue(prop);
  }



boolean propertyTrue(char property, TFormula term){


  char individual = valueFunctionalTerm(term);

  return
      (fShapePanel.getSemantics()).propertyTrue(property,individual);
}

/*

  function TDeriverDocument.PropertyTrue (property: CHAR; term: TFormula): BOOLEAN;
   var
    searchStr: string[1];
  begin
   searchStr := 'a';
   searchStr[1] := ValueFunctionalTerm(term);
   PropertyTrue := pos(searchStr, SELF.fCurrentProperties[property]) <> 0;
  end;



*/

boolean relationTrue(char relation, TFormula firstTerm, TFormula secondTerm){


  char fromCh = valueFunctionalTerm(firstTerm);
  char toCh = valueFunctionalTerm(secondTerm);

return
    (fShapePanel.getSemantics()).relationTrue(relation,fromCh,toCh);
}



  char exiQuantVerifier(TFormula root){

    // this tests whether a exiquant is trur and returns verifying individual

    boolean exiTrue=false;
    char individual=chBlank;
    TFormula term= new TFormula();
    TFormula scope;

    String individuals = fShapePanel.getSemantics().getCurrentUniverse();

    term.fKind=TFormula.functor;

    int i=0;

    while ((i<individuals.length())&&!exiTrue){
      individual=individuals.charAt(i);

      term.fInfo=String.valueOf(individual);

      scope=(root.fRLink).copyFormula();

      scope.subTermVar(scope,term,root.quantVarForm());

      exiTrue=formulaTrue(scope);

      i++;
    }

    if (exiTrue)
      return
          individual;
    else
       return
          chBlank;

  }


/*

   function TDeriverDocument.ExiquantTrue (root: TFormula; var individual: CHAR): BOOLEAN;

  {This tests whether Exi is true and returns individual if so}

    var
     exiTrue: BOOLEAN;
     testFormula, termForm: TFormula;
     currentUniverse: str255;
     index: integer;

   begin
    exiTrue := FALSE;
    currentUniverse := SELF.fCurrentUniverse;
    individual := chBlank;


    SupplyFormula(termForm);
    termForm.fKind := functor;

    index := 1;
    while (index <= length(currentUniverse)) and not exiTrue do
     begin
      individual := currentUniverse[index];
      termForm.fInfo := individual;
      testFormula := root.fRlink.CopyFormula;
      NewSubTermVar(testFormula, termForm, root.QuantVarForm);
      exiTrue := FormulaTrue(testFormula);
      testFormula.DismantleFormula;
      index := index + 1;
     end;

    termForm.DismantleFormula;
    ExiquantTrue := exiTrue;
   end;



*/

char freeFalsifier(TFormula root,char freeCh){

  // this tests whether a root with free char can be false and returns falsifying individual

  boolean falsifierTrue=true;
  char individual=chBlank;
  TFormula test;
  TFormula term= new TFormula();

  String individuals = fShapePanel.getSemantics().getCurrentUniverse();

  term.fKind=TFormula.functor;

  int i=0;

  while ((i<individuals.length())&&falsifierTrue){
    individual=individuals.charAt(i);

    term.fInfo=String.valueOf(individual);

    test=root.copyFormula();

    test.subTermVar(test,term,new TFormula(TFormula.variable,String.valueOf(freeCh),null,null));

    falsifierTrue=formulaTrue(test);

    i++;
  }

  if (falsifierTrue)
    return
        chBlank;
  else
     return
      individual;

}

  char freeVerifier(TFormula root,char freeCh){

     // this tests whether formula with a free variable can be is true and returns verifying individual

     boolean verifierTrue=false;
     char individual=chBlank;
     TFormula term= new TFormula();
     TFormula test;

     String individuals = fShapePanel.getSemantics().getCurrentUniverse();

     term.fKind=TFormula.functor;

     int i=0;

     while ((i<individuals.length())&&!verifierTrue){
       individual=individuals.charAt(i);

       term.fInfo=String.valueOf(individual);

       test=root.copyFormula();

       test.subTermVar(test,term,new TFormula(TFormula.variable,String.valueOf(freeCh),null,null));

       verifierTrue=formulaTrue(test);

       i++;
     }

     if (verifierTrue)
       return
           individual;
     else
        return
           chBlank;
  }


char uniQuantFalsifier(TFormula root){

  // this tests whether a uniquant is fasle and returns falsifying individual

  boolean uniTrue=true;
  char individual=chBlank;
  TFormula term= new TFormula();
  TFormula scope;

  String individuals = fShapePanel.getSemantics().getCurrentUniverse();

  term.fKind=TFormula.functor;

  int i=0;

  while ((i<individuals.length())&&uniTrue){
    individual=individuals.charAt(i);

    term.fInfo=String.valueOf(individual);

    scope=(root.fRLink).copyFormula();

    scope.subTermVar(scope,term,root.quantVarForm());

    uniTrue=formulaTrue(scope);

    i++;
  }

  if (uniTrue)
    return
        chBlank;
  else
     return
      individual;

}

/*

   function TDeriverDocument.UniquantTrue (root: TFormula; var individual: CHAR): BOOLEAN;

   {This tests whether Uni is true and returns falsif individual if so}

     var
      uniTrue: BOOLEAN;
      testFormula, termForm: TFormula;
      currentUniverse: str255;
      index: integer;

    begin
     uniTrue := TRUE;
     currentUniverse := SELF.fCurrentUniverse;
     individual := chBlank;


     SupplyFormula(termForm);
     termForm.fKind := functor;

     index := 1;
     while (index <= length(currentUniverse)) and uniTrue do
      begin
       individual := currentUniverse[index];
       termForm.fInfo := individual;
       testFormula := root.fRlink.CopyFormula;
       NewSubTermVar(testFormula, termForm, root.QuantVarForm);
       uniTrue := FormulaTrue(testFormula);
       testFormula.DismantleFormula;
       index := index + 1;
      end;

     termForm.DismantleFormula;
     UniquantTrue := uniTrue;
    end;





*/

public boolean equalityTrue(TFormula root){
  return
      valueFunctionalTerm(root.firstTerm()) == valueFunctionalTerm(root.secondTerm());
}


/*
 function TDeriverDocument.EqualityTrue (root: TFormula): BOOLEAN;

 begin
  EqualityTrue := ValueFunctionalTerm(root.FirstTerm) = ValueFunctionalTerm(root.SecondTerm)
 end;

*/


 public boolean atomicFormulaTrue(TFormula root){

   if (root.isSpecialPredefined()){  // true, false, or absurd
      if (root.equalFormulas(root,TFormula.fTruth))
                return
                    true;
              else
                return
                    false;    // covers false and absurd

   }
   else{




              switch (root.arity()) {

                case 0:
                  return
                      propositionTrue(root.propositionName());

                case 1:
                  return
                      propertyTrue(root.propertyName(), root.firstTerm());

                case 2:
                  return
                      relationTrue(root.propertyName(), root.firstTerm(),
                                   root.secondTerm());

                default:

                    writeToJournal(TConstants.fErrors2, kHIGHLIGHT, !kTO_MARKER); //not truth for ternary predicates eetc

              }

              return
                  false;
            }
 }

 /*

  function TDeriverDocument.AtomicFormulaTrue (root: TFormula): BOOLEAN;

   var
    tempBoolean: BOOLEAN;

  begin
   tempBoolean := FALSE;

   case root.Arity of
    0:
     tempBoolean := fCurrentPropositions[root.fInfo[1]]; {proposition}
    1:
     tempBoolean := PropertyTrue(root.fInfo[1], root.FirstTerm);
    2:
     tempBoolean := RelationTrue(root.fInfo[1], root.FirstTerm, root.SecondTerm);

    otherwise
     if root.SpecialPredefined then
      begin
       if equalformulas(root, gTrueFormula) then
        tempBoolean := true
       else
        tempBoolean := false; (*covers false and absurd*)
      end
     else
      WriteToJournal(gErrorsArray[2], TRUE, FALSE);
   end;

   AtomicFormulaTrue := tempBoolean;
  end;




 */

public TParser getParser(){
  return
      fParser;
}

public TShapePanel getShapePanel(){
  return
      fShapePanel;
}








public boolean formulaTrue(TFormula root){

 if (root==null)                 //should never happen
   return
       false;


  switch (root.fKind){

    case TFormula.predicator:
      return
          atomicFormulaTrue(root);

    case TFormula.equality:
      return
         equalityTrue(root);


    case TFormula.unary:
      return
          !formulaTrue(root.fRLink);

    case TFormula.binary:
      if (fParser.isAnd(root))
        return
            (formulaTrue(root.fLLink)&&formulaTrue(root.fRLink));

      if (fParser.isOr(root))
         return
          (formulaTrue(root.fLLink)||formulaTrue(root.fRLink));

      if (fParser.isImplic(root))
         return
          ((!formulaTrue(root.fLLink))||formulaTrue(root.fRLink));

       if (fParser.isEquiv(root))
         return
          (((!formulaTrue(root.fLLink))||formulaTrue(root.fRLink))&&
           (formulaTrue(root.fLLink)||(!formulaTrue(root.fRLink))));


   case TFormula.quantifier:

       if (fParser.isUniquant(root))
          return
              (uniQuantFalsifier(root)==chBlank);

       if (fParser.isExiquant(root))
          return
              (exiQuantVerifier(root)!=chBlank);

        if (fParser.isUnique(root)){
          TFormula expansion=root.expandUnique();

          if (expansion==null) //rare, no more variables
            return
                false;
          else
             return
              formulaTrue(expansion);
        }

      case TFormula.typedQuantifier:
        TFormula expansion=null;

          if (fParser.isTypedUniquant(root))
             expansion=fParser.expandTypeUni(root);
          else
          if (fParser.isTypedExiquant(root))
             expansion=fParser.expandTypeExi(root);


             if (expansion==null) //should not happen
               return
                   false;
             else
                return
                 formulaTrue(expansion);

    default:
      ;
  }

  return
      false;

}


/*

  function TDeriverDocument.FormulaTrue (root: TFormula): BOOLEAN;

var
 itsTruth: BOOLEAN;
 itsMainConnective, dummy: CHAR;

begin
itsTruth := FALSE;

case root.fKind of
 predicator:
  itsTruth := AtomicFormulaTrue(root); {atomic}
 equality:
  itsTruth := EqualityTrue(root); {equality}
 unary:
  itsTruth := not FormulaTrue(root.fRlink); {negation}
 binary:
  begin
   itsMainConnective := root.fInfo[1];
   case itsMainConnective of
    chAnd:
     itsTruth := FormulaTrue(root.fLlink) and FormulaTrue(root.fRlink);
    chOr:
     itsTruth := FormulaTrue(root.fLlink) or FormulaTrue(root.fRlink);
    chImplic:
     itsTruth := (not FormulaTrue(root.fLlink)) or FormulaTrue(root.fRlink);
    chEquiv:
     itsTruth := ((not FormulaTrue(root.fLlink)) or FormulaTrue(root.fRlink)) and ((not FormulaTrue(root.fRlink)) or FormulaTrue(root.fLlink));

    otherwise
   end;
  end;
 quantifier:
  begin
   itsMainConnective := root.fInfo[1];
   case itsMainConnective of
    chUniquant:
     itsTruth := UniquantTrue(root, dummy);
    chExiquant:
     itsTruth := ExiquantTrue(root, dummy);

    otherwise
   end;
  end;

 otherwise

end;
FormulaTrue := itsTruth;
end;


*/


/* A number of commands involve bridging from LISP to Java-- we read and parse a LISP input
but then do some Java commands. This is a class to keep that largely in one place so that the
LISP can be replaced, if desired, without creating havoc.*/

public class TLispJava{


    /********************************** COMMANDS ****************************************/


    private int identify(String inputStr) {

      if (inputStr.indexOf("(assign true") == 0)
        return
            0;

      if (inputStr.indexOf("(assign false") == 0)
        return
            1;

      if (inputStr.indexOf("(remember adjective") == 0)
        return
            2;

      if (inputStr.indexOf("(remember iverb") == 0)
        return
            3;

      if (inputStr.indexOf("(remember proposition") == 0)
        return
            4;

      if (inputStr.indexOf("(remember name") == 0)
        return
            5;

      if (inputStr.indexOf("(remember noun") == 0)
        return
            6;

      if (inputStr.indexOf("(remember tverb") == 0)
        return
            7;

      if (inputStr.indexOf("(remember pverb") == 0)
        return
            8;

      if (inputStr.indexOf("(remember binadj") == 0)
        return
            9;

      if (inputStr.indexOf("(write propositions") == 0)
        return
            10;

   /*   if (inputStr.indexOf("(all") == 0)
        return
            11; not doing that here */

      return
          -1;
    }

    void processAll(String inputStr, Object lispInput) {

      /*This starts "(all and then there should be a bunch
        of other commands (cmd1 ) (cmd2) etc).

       We can pick them off by lISP, get their strings and let the
       command interpeter deal with them*/



      Object cdr=TScheme.globalLispEvaluate("(cdr '"+inputStr+")"); //drop all
      Object car;
      String cdrStr;
      boolean lispSyntax=true;

      while (cdr!=null){
        cdrStr=cdr.toString();
        car=TScheme.globalLispEvaluate("(car '"+cdrStr+")"); //get command, and interpet adds brackets
        interpretCommand(car.toString(),lispSyntax);
        writeToJournal(strCR, !kHIGHLIGHT, !kTO_MARKER);  // different command outputs on new lines
        cdr=TScheme.globalLispEvaluate("(cdr '"+cdrStr+")"); //drop command we've done

      }

  }


  void process(int type, String inputStr, Object lispInput){
    /*Some of these involve semantics (and these are passed to the
     semantics) and others involve symbolization (and these
 are passed to the LISP in EnglishToLogic*/

  /*it has the input as lisp and as string*/

  String message=null;


    switch (type){
      case 0: if (assignTrue(inputStr))
            writeToJournal("OK", kHIGHLIGHT, !kTO_MARKER);
        break;

      case 1: if (assignFalse(inputStr))
            writeToJournal("OK", kHIGHLIGHT, !kTO_MARKER);
        break;

      case 2:
         message= fEToL.rememberAdjective(lispInput);
        break;

      case 3:
        message= fEToL.rememberIVerb(lispInput);
       break;

      case 4:
         message= fEToL.rememberProposition(lispInput);
        break;

      case 5:
       message= fEToL.rememberName(lispInput);
      break;

      case 6:
        message= fEToL.rememberNoun(lispInput);
       break;

      case 7:
      message= fEToL.rememberTVerb(lispInput);
      break;

      case 8:
           message= fEToL.rememberPVerb(lispInput);
          break;

      case 9:
                message= fEToL.rememberBinAdj(lispInput);
               break;

      case 10:
         message= fEToL.writeAssocList(fEToL.lispEvaluate("gPropositions"));

        break;

      case 11:
          processAll(inputStr,lispInput);


      default:

    }

    if (message!=null){
      if (fJournal==null)
  System.out.println("writeOverJournalSelection() called with null Journal");
else

      fJournal.writeOverJournalSelection(message);
    }
    else
       Toolkit.getDefaultToolkit().beep();

  }

/*

boolean rememberProposition(String inputStr){
  /* we know that inputStr starts "(remember proposition " and ends ")" what happens in the
  middle is open to conjecture

  return
      false;
}

*/



  void symbolize(String inputStr, boolean propChosen){

    /*
      {This should read a selection from some text, and attempt to make one step of a}
     {symbolization of it.   If it can do so and the symbolization is unique it should replace}
     {the selection with the symbolization. If it can do so and the symbolization is not}
     { unique it should replace the selection with a list of symbolizations.   If it cannot}
     {symbolize the selection it should beep and leave the selection as it was.}

     (*The idea here is that we read the selection, and if we transform it we write*)
     (*over that very selection.  If a transformation is not suitable we leave the original*)
     (*as it was.*)


 */

/*

    Sound

You need to import the Toolkit class:
   import java.awt.Toolkit;


Use this statment in your code:
   Toolkit.getDefaultToolkit().beep();


    */



    /*this already has been filtered before
     it gets here. At the moment the filtering puts it in upper case (but then the LISP puts it
     back in lower csdr */

   // Object english_word_list=null;

    inputStr="(" + inputStr + ")";  // we'll make it into a list so that the LISP parser can parse it

/*

    writeToJournal(inputStr, kTConstants.HIGHLIGHT, !kTO_MARKER);;


    try {

       boolean quoted=true;

       InputPort input = new InputPort(new StringReader(inputStr));



       if (input.isEOF(english_word_list = input.read()))
               return;


    System.out.println(SchemeUtils.stringify(english_word_list, !quoted));


           }

   catch (Exception ex) {

     writeToJournal("Scheme Exception: " + ex, true, false);

     System.err.println("Scheme Exception: " + ex);
    }
 }

*/

/*   if (english_word_list!=null)
     TEnglishToLogic.symbolizeOneStep(english_word_list,propChosen); */

String resultStr=fEToL.symbolizeOneStep(inputStr,propChosen);

if (resultStr!=null){
  if (fJournal==null)
  System.out.println("writeOverJournalSelection() called with null Journal");
else

  fJournal.writeOverJournalSelection(resultStr);
}
else
   Toolkit.getDefaultToolkit().beep();
  }

 /*
  begin
     if CollectionWise then
      if collectGarbage then
       ;

     ReadSelection(fDeriverDocument.fJournalTEView.fHTE);
     GetInput;
     skip(1, peculiarfilter);  (*primes gCurrch, and gLookaheadCh*)
     scan(peculiarfilter);

     getexplist(english_word_list, peculiarfilter);

     if fDeriverDocument.fJournalTEView.Focus then
      ;

     if TRadio(SELF.FindSubView('jou1')).IsOn then
      SymbolizeOneStep(kPropAnalysis, english_word_list, success)
     else
      SymbolizeOneStep(kPredAnalysis, english_word_list, success);

     if success then
      begin
       if fDeriverDocument.fJournalTEView.Focus then
       ;

       gOutputStream.WriteOverSelection(fDeriverDocument.fJournalTEView.fHTE);

       fDeriverDocument.fJournalTEView.SynchView(TRUE);  {true means redraw}

      end
     else
      sysBeep(5);

    end;




  */

 void translate(String inputStr){


 {StringReader aStringReader= new StringReader(inputStr);

     if (aStringReader!=null) {

       TFormula root = new TFormula();
       boolean wellformed;
       ArrayList dummy = new ArrayList();

       wellformed=fParser.wffCheck(root,/* dummy,*/ aStringReader);

       if (wellformed){
         String translation=fEToL.translateBack(root, fParser);

         if (translation!=null){
           if (fJournal==null)
  System.out.println("writeOverJournalSelection() called with null Journal");
else

           fJournal.writeOverJournalSelection(translation);
         }
         else
            Toolkit.getDefaultToolkit().beep();

       }

      }}

   }




 /*

  (*The beginners version translates logic to english instead of endorse-deny*)
    begin
     gInputStr := strNull;
     gOutputStr := strNull;
     gIllformed := FALSE;
     ReadSelection(fDeriverDocument.fJournalTEView.fHTE);
                    {This primes inputHdl and indices}

     GetInput;
     skip(1, LogicFilter);  (*primes gCurrch, and gLookaheadCh*)

     DoParsing(gRoot, newValuation, gIllformed);  (*overriden for different parsers*)


     if not gIllformed then
      begin
       if TranslateBack(gRoot, fDeriverDocument.fParser) then
       begin
       if fDeriverDocument.fJournalTEView.Focus then
       ;
       gOutputStream.WriteOverSelection(fDeriverDocument.fJournalTEView.fHTE);
       if fDeriverDocument.fJournalTEView.Focus then
       ;

       fDeriverDocument.fJournalTEView.SynchView(TRUE);  {true means redraw}


       end
       else
       sysbeep(5);
       gRoot.DismantleFormula;
      end;

    end;


  */



boolean assignFalse(String inputStr){
  /* we know that inputStr starts "(assign false " and ends ")" what happens in the
  middle is open to conjecture*/

  boolean changes=false;

  String target = inputStr.substring("(assign false ".length());

  target=target.toUpperCase();

  String possible =fShapePanel.getSemantics().getPossiblePropositions();

  for (int i=0;i<target.length()-1;i++){
    int index = possible.indexOf(target.charAt(i));
    if (index>-1){

      if (fShapePanel.getSemantics().fCurrentPropositions[index]){

        fShapePanel.getSemantics().fCurrentPropositions[index]=false;
        changes=true;

      }
    }

  }
  return
      changes;
}

boolean assignTrue(String inputStr){
  /* we know that inputStr starts "(assign true " and ends ")" what happens in the
  middle is open to conjecture*/

  boolean changes=false;

  String target = inputStr.substring("(assign true ".length());

  target=target.toUpperCase();

  String possible =fShapePanel.getSemantics().getPossiblePropositions();

  for (int i=0;i<target.length()-1;i++){
    int index = possible.indexOf(target.charAt(i));
    if (index>-1){

      if (!fShapePanel.getSemantics().fCurrentPropositions[index]){

        fShapePanel.getSemantics().fCurrentPropositions[index]=true;
        changes=true;

      }
    }

  }
  return
      changes;
}



/*

   proce dure HandleAssign (locallist: integer);
       var
        assignedBool, changes: boolean;
        charIndex: string;
      begin
       assignedBool := false;
       changes := false;
       key := StringToUpperCase(svalue(first(locallist)));
       if (key = 'TRUE') then
        assignedBool := true;
       locallist := cdr(locallist);
       while listlength(locallist) > 0 do
        begin
         charIndex := svalue(first(locallist));
         if length(charIndex) = 1 then
          if (charIndex[1] in ['A'..'Z']) then
          begin
          itsDocument.fCurrentPropositions[charIndex[1]] := assignedBool;
          changes := true;
          end;
         locallist := cdr(locallist);
        end;
       if changes then
        itsDocument.WriteToJournal('OK', kTConstants.HIGHLIGHT, not kTO_MARKER);
      end;



*/

/******************************Experiments ******************/

public Object applyFunction (Object function, Object argList){

  boolean quoted = true;

  Object form = SchemeUtils.cons(function,argList);

  System.out.println("form ");


  String resultStr = SchemeUtils.stringify(form, !quoted);



                 System.out.println(resultStr);


  return
      TScheme.fScheme.eval(form);


}

public void tryLisp(){

  boolean quoted = true;

  String inputStr= "(define (extract-key binding) (car binding))";

  Object function;
  Object functionText;
  Object arglist;

  try {

           InputPort input = new InputPort(new StringReader(inputStr));


             Object result;
             String resultStr;
             if (input.isEOF(functionText = input.read()))
               return;


             System.out.println(functionText);

               resultStr = SchemeUtils.stringify(functionText, !quoted);



                 System.out.println(resultStr);

                 function = TScheme.fScheme.eval(functionText);


             inputStr= "('(X (FRED) Y))";

             input = new InputPort(new StringReader(inputStr));


             if (input.isEOF(arglist = input.read()))
               return;


             System.out.println(arglist);

               resultStr = SchemeUtils.stringify(arglist, !quoted);



                 System.out.println(resultStr);

                 result=applyFunction(function,arglist);

                 TScheme.fScheme.eval(function);

              //   result = fApplication.fScheme.eval(function);

               resultStr = SchemeUtils.stringify(result, !quoted);

               System.out.println(resultStr);

               writeToJournal("Scheme output: " + resultStr, true, false);





           }

   catch (Exception ex) {

     writeToJournal("Scheme Exception: " + ex, true, false);

     System.err.println("Scheme Exception: " + ex);
    }


}



  public void doCommand(String inputStr){
   boolean quoted = true;

   {
     //   myLisp.init();
     //   myLisp.start();

         try {

           InputPort input = new InputPort(new StringReader(inputStr));

           {
             Object x;
             Object result;
             String resultStr;
             if (input.isEOF(x = input.read()))
               return;
             //   write(eval(x), output, true); }

          //   System.out.println(x);                       //test in May

               resultStr = SchemeUtils.stringify(x, !quoted);

               int oneOfOurs= identify(resultStr);

               if (oneOfOurs>-1){
                 process(oneOfOurs, resultStr,x);

            //     System.out.println(resultStr);
               }
             else{                                   // let lisp process it

               result = TScheme.fScheme.eval(x);

               resultStr = SchemeUtils.stringify(result, !quoted);

          //     System.out.println(resultStr);

               writeToJournal("Scheme output: " + resultStr, true, false);
             }

           }
         }
       catch (Exception ex) {

         writeToJournal("Scheme Exception: " + ex, true, false);

     //    System.err.println("Scheme Exception: " + ex);
        }




        }


 }


public void interpretCommand(String inputStr,boolean lispSyntax){

  if (!lispSyntax)
    inputStr="(" + inputStr + ")";  // we'll make it into a list so that the LISP parser can parse it


  boolean quoted = true;

 try {

   InputPort input = new InputPort(new StringReader(inputStr));
   Object lispInput;
   Object result;
   String resultStr;

   if (input.isEOF(lispInput = input.read()))
               return;


   resultStr = SchemeUtils.stringify(lispInput, !quoted);

   int oneOfOurs= identify(resultStr);

   if (oneOfOurs>-1){
                 process(oneOfOurs, resultStr, lispInput);

             //    System.out.println(resultStr);
               }
             else{

             Toolkit.getDefaultToolkit().beep();


             // let lisp process it

            /*   result = fApplication.fScheme.eval(lispInput);

               resultStr = SchemeUtils.stringify(result, !quoted);

               System.out.println(resultStr);

               writeToJournal("Scheme output: " + resultStr, true, false); */
             }


         }
       catch (Exception ex) {

         writeToJournal("Scheme Exception: " + ex, true, false);

         System.err.println("Scheme Exception: " + ex);
        }


/*  String resultStr=null; //fApplication.fEToL.symbolizeOneStep(inputStr,propChosen);

if (resultStr!=null)
  fBrowser.writeOverJournalSelection(resultStr);
else
   Toolkit.getDefaultToolkit().beep(); */
  }


  /*

     begin

     ReadSelection(inText);
                       {This primes inputHdl and indices}

     GetInput;
     skip(1, Lispfilter);  (*primes gCurrch, and gLookaheadCh changed form standard*)
     scan(Lispfilter);

     getexplist(english_word_list, Lispfilter);

     if listlength(english_word_list) > 1 then
      process(english_word_list);
    end;


  }*/






 /************************************************************************************/


}

  //CHECK MAYBE ERROR HERE IF SEVERAL FREE VARIABLES

void placeMarker(){
  writeToJournal(""+chInsertMarker, !TConstants.HIGHLIGHT, TConstants.TO_MARKER);
}


public void iDeny(TFormula root, ArrayList valuation){
    TFormula tempFormula,leftFormula,rightFormula;
    char freeCh,instantiation;

    if ((fShapePanel.getSemantics().universeEmpty())&&(root.termsInFormula()!=null)){
       writeToJournal(TConstants.fErrors1, TConstants.HIGHLIGHT,
           !TConstants.TO_MARKER);
       return;                     //error
       }

 String individuals = fShapePanel.getSemantics().getCurrentUniverse();  //non empty



    leftFormula=root.getLLink();
    rightFormula=root.getRLink();

    writeToJournal(strCR+
                   "I denied "+
                   fParser.writeFormulaAndWrap(root)+
                   writeShortValuation(),
                   !TConstants.HIGHLIGHT,
                   TConstants.TO_MARKER);
    placeMarker();

    /*WriteToJournal(concat(gCR, 'I denied '), FALSE, gTConstants.TO_MARKER);
gOutputStr := '';
WriteFormula(root);
WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
gOutputStr := '';
WriteShortValuation;
PlaceMarker;


    */

   tempFormula=root.copyFormula();
   tempFormula.interpretFreeVariables(fValuation);

   //freeCh = tempFormula.firstFreeVar();
   
   freeCh = fParser.firstFreeVar(tempFormula);

   if (freeCh != chBlank) {
      if (fParser.addToValuation('?',freeCh,fValuation))
     ;
   instantiation=freeFalsifier(root,freeCh);
   if (instantiation==chBlank)
           instantiation=individuals.charAt(0);  //any will do if cannot falsify
   if (fParser.addToValuation(instantiation,freeCh,fValuation))
      ;

      iDeny(root,valuation);
   }



  /*tempFormula := root.CopyFormula; {check this next section}
InterpretFreeVariables(tempFormula);
if FirstVarFree(tempFormula, freeCh) then
begin
 if FreeFalse(tempFormula, freeCh, instantiation) then
  ;
 tempFormula.DismantleFormula;

 AddtoValuation(instantiation, freeCh); {this should value the freech to the refuting}
{                                                       instant}
            { SubTermVar(root, instantiation, freeCh);}
 IDeny(root, valuation);


    */

   else if((root.fKind == TFormula.predicator) ||
          (root.fKind == TFormula.equality)){
             Toolkit.getDefaultToolkit().beep();
             if (valuedFormulaTrue(root))
               writeToJournal(TConstants.fErrors10,!TConstants.HIGHLIGHT,TConstants.TO_MARKER);  //wrong answer
             else
               writeToJournal(TConstants.fErrors9,!TConstants.HIGHLIGHT,TConstants.TO_MARKER);  //right answer
   }
   /*  if (root.fKind = predicator) or (root.fKind = equality) then
      begin
       SysBeep(5);
       if ValuedFormulaTrue(root) then {atomic}
        WriteToJournal(gErrorsArray[10], FALSE, gTConstants.TO_MARKER) {wrong answer}
       else
        WriteToJournal(gErrorsArray[9], FALSE, gTConstants.TO_MARKER); {right answer}
      end

*/
else{
  switch (root.fKind){
    case TFormula.unary:
      iEndorse(rightFormula,valuation);
      break;
      /*
           chNeg:
     IEndorse(rightFormula, valuation);

     chAnd:

     if ValuedFormulaTrue(leftFormula) then

     IDeny(rightFormula, valuation)

     else

     IDeny(leftFormula, valuation);


*/

    case TFormula.binary:
      if (fParser.isAnd(root)){
        if (valuedFormulaTrue(leftFormula))
          iDeny(rightFormula,valuation);
        else
          iDeny(leftFormula,valuation);
      };

      if (fParser.isOr(root)){
        writeToJournal(strCR +
         "You should endorse " +
         fParser.writeFormulaAndWrap(leftFormula)+
         writeShortValuation()+
         strCR +
         "Or you should endorse " +
         fParser.writeFormulaAndWrap(rightFormula)+
         writeShortValuation()
         ,!TConstants.HIGHLIGHT,
          TConstants.TO_MARKER);
        placeMarker();
      };


 /*
           begin
     WriteToJournal(concat(gCR, 'You should endorse '), FALSE, gTConstants.TO_MARKER);
     gOutputStr := '';
     WriteFormula(leftFormula);
     WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
     WriteShortValuation;
     WriteToJournal(concat(gCR, 'Or you should endorse '), FALSE, gTConstants.TO_MARKER);
     gOutputStr := '';
     WriteFormula(rightFormula);
     WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
     WriteShortValuation;
     PlaceMarker;

     end;

 */


      if (fParser.isImplic(root)){
        writeToJournal(strCR +
         "You should deny " +
         fParser.writeFormulaAndWrap(leftFormula)+
         writeShortValuation()+
         strCR +
         "Or you should endorse " +
         fParser.writeFormulaAndWrap(rightFormula)+
         writeShortValuation()
         ,!TConstants.HIGHLIGHT,
          TConstants.TO_MARKER);
        placeMarker();
      };


      /*     chImplic:
    begin
    WriteToJournal(concat(gCR, 'You should deny '), FALSE, gTConstants.TO_MARKER);
    gOutputStr := '';
    WriteFormula(leftFormula);
    WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
    WriteShortValuation;
    WriteToJournal(concat(gCR, 'Or you should endorse '), FALSE, gTConstants.TO_MARKER);
    gOutputStr := '';
    WriteFormula(rightFormula);
    WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
    WriteShortValuation;
    PlaceMarker;

    end;


      */

      if (fParser.isEquiv(root)){
        TFormula implicFormula;
       if ((valuedFormulaTrue(leftFormula))&&
           !(valuedFormulaTrue(rightFormula))){
         implicFormula=new TFormula(TFormula.binary,
                                    String.valueOf(chImplic),
                                    leftFormula,
                                    rightFormula);
         iDeny(implicFormula,valuation);
       }
       else{
         implicFormula=new TFormula(TFormula.binary,
                                    String.valueOf(chImplic),
                                    rightFormula,
                                    leftFormula);
         iDeny(implicFormula,valuation);
       }

     };
     break;


/*
                chEquiv:
          begin
          if (ValuedFormulaTrue(leftFormula) and not ValuedFormulaTrue(root.fRlink)) then
          begin
          root.fInfo[1] := chImplic;
          IDeny(root, valuation);
          end
          else
          begin
          tempFormula := root.fLlink;
          root.fLlink := root.fRlink;
          root.fRlink := tempFormula;
          tempFormula := nil;
          root.fInfo[1] := chImplic;
          IDeny(root, valuation);
          end;
          end;


*/

   case TFormula.quantifier:

       if (fParser.isUniquant(root)){
         tempFormula=root.copyFormula();
         tempFormula.interpretFreeVariables(fValuation);

         instantiation=uniQuantFalsifier(tempFormula);

         if (instantiation==chBlank)
           instantiation=individuals.charAt(0);  //any will do

         if (fParser.addToValuation(instantiation,
        		 root.quantVar().charAt(0),fValuation))  //ignore subscripts
        ;
      iDeny(root.scope(),valuation);
       }

       /*     begin
     tempFormula := root.CopyFormula; {check this next section}
     InterpretFreeVariables(tempFormula);

     if UniquantTrue(tempFormula, instantiation) then
     ;
                            {this primes instantiation with an instnat}

     tempFormula.DismantleFormula;

     AddtoValuation(instantiation, root.QuantVar);

     IDeny(rightFormula, valuation);
     end;

       */

       if (fParser.isExiquant(root)){

          if (fParser.addToValuation('?',root.quantVar().charAt(0),fValuation))
             ;

   writeToJournal(strCR +
                  "You should endorse " +
                  fParser.writeFormulaAndWrap(root.scope())+
                  writeShortValuation()+
                  strCR+
                  "for a ? that you choose. "
                  ,!TConstants.HIGHLIGHT,
                   TConstants.TO_MARKER);

   placeMarker();
   clearValuation();
       }
       /*       chExiquant:
            begin
            WriteToJournal(concat(gCR, 'You should endorse '), FALSE, gTConstants.TO_MARKER);
            gOutputStr := '';
            WriteFormula(rightFormula);
            WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
            AddtoValuation('?', root.QuantVar);
            WriteShortValuation;
            WriteToJournal(concat(gCR, 'for a ? that you choose. '), FALSE, gTConstants.TO_MARKER);
            fvaluation.DeleteAll; {this does not free objects, should do}

                                   {avoids leaving a question mark}
            PlaceMarker;
            end;


*/
       if (fParser.isUnique(root)){
         TFormula expansion = root.expandUnique();
         if (expansion!=null)
           iDeny(expansion,valuation);
       }
       break;


     case TFormula.typedQuantifier:

       TFormula expansion=null;

       if (fParser.isTypedUniquant(root))
         expansion=fParser.expandTypeUni(root);
       else
       if (fParser.isTypedExiquant(root))
         expansion=fParser.expandTypeExi(root);


     if (expansion==null) //should not happen
        iDeny(expansion,valuation);
      break;

    default:
      ;
  }


}

}


/*
 procedure TDeriverDocument.IDeny (var root: TFormula; valuation: TList);

var
 itsMainConnective, instantiation, freeCh: CHAR;
 itsTruth: BOOLEAN;
 tempFormula, leftFormula, rightFormula: TFormula;

procedure PlaceMarker;

begin
 WriteToJournal(chInsertMarker, FALSE, gTConstants.TO_MARKER);
end;

begin
leftFormula := root.fLlink;
rightFormula := root.fRlink;

WriteToJournal(concat(gCR, 'I denied '), FALSE, gTConstants.TO_MARKER);
gOutputStr := '';
WriteFormula(root);
WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
gOutputStr := '';
WriteShortValuation;
PlaceMarker;

tempFormula := root.CopyFormula; {check this next section}
InterpretFreeVariables(tempFormula);
if FirstVarFree(tempFormula, freeCh) then
 begin
  if FreeFalse(tempFormula, freeCh, instantiation) then
   ;
  tempFormula.DismantleFormula;

  AddtoValuation(instantiation, freeCh); {this should value the freech to the refuting}
{                                                       instant}
             { SubTermVar(root, instantiation, freeCh);}
  IDeny(root, valuation);
 end
else
 begin
  tempFormula.DismantleFormula;

  if (root.fKind = predicator) or (root.fKind = equality) then
   begin
    SysBeep(5);
    if ValuedFormulaTrue(root) then {atomic}
     WriteToJournal(gErrorsArray[10], FALSE, gTConstants.TO_MARKER) {wrong answer}
    else
     WriteToJournal(gErrorsArray[9], FALSE, gTConstants.TO_MARKER); {right answer}
   end
  else
   begin
    itsMainConnective := root.fInfo[1];
    case itsMainConnective of

     chNeg:
     IEndorse(rightFormula, valuation);

     chAnd:

     if ValuedFormulaTrue(leftFormula) then

     IDeny(rightFormula, valuation)

     else

     IDeny(leftFormula, valuation);

     chOr:
     begin
     WriteToJournal(concat(gCR, 'You should endorse '), FALSE, gTConstants.TO_MARKER);
     gOutputStr := '';
     WriteFormula(leftFormula);
     WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
     WriteShortValuation;
     WriteToJournal(concat(gCR, 'Or you should endorse '), FALSE, gTConstants.TO_MARKER);
     gOutputStr := '';
     WriteFormula(rightFormula);
     WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
     WriteShortValuation;
     PlaceMarker;

     end;

     chImplic:
     begin
     WriteToJournal(concat(gCR, 'You should deny '), FALSE, gTConstants.TO_MARKER);
     gOutputStr := '';
     WriteFormula(leftFormula);
     WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
     WriteShortValuation;
     WriteToJournal(concat(gCR, 'Or you should endorse '), FALSE, gTConstants.TO_MARKER);
     gOutputStr := '';
     WriteFormula(rightFormula);
     WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
     WriteShortValuation;
     PlaceMarker;

     end;

     chEquiv:
     begin
     if (ValuedFormulaTrue(leftFormula) and not ValuedFormulaTrue(root.fRlink)) then
     begin
     root.fInfo[1] := chImplic;
     IDeny(root, valuation);
     end
     else
     begin
     tempFormula := root.fLlink;
     root.fLlink := root.fRlink;
     root.fRlink := tempFormula;
     tempFormula := nil;
     root.fInfo[1] := chImplic;
     IDeny(root, valuation);
     end;
     end;

     chUniquant:
     begin
     tempFormula := root.CopyFormula; {check this next section}
     InterpretFreeVariables(tempFormula);

     if UniquantTrue(tempFormula, instantiation) then
     ;
                            {this primes instantiation with an instnat}

     tempFormula.DismantleFormula;

     AddtoValuation(instantiation, root.QuantVar);

     IDeny(rightFormula, valuation);
     end;

     chExiquant:
     begin
     WriteToJournal(concat(gCR, 'You should endorse '), FALSE, gTConstants.TO_MARKER);
     gOutputStr := '';
     WriteFormula(rightFormula);
     WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
     AddtoValuation('?', root.QuantVar);
     WriteShortValuation;
     WriteToJournal(concat(gCR, 'for a ? that you choose. '), FALSE, gTConstants.TO_MARKER);
     fvaluation.DeleteAll; {this does not free objects, should do}

                            {avoids leaving a question mark}
     PlaceMarker;
     end;

     otherwise
    end;

   end;
 end;
 end;


public void iEndorse(TFormula root, ArrayList valuation){

  writeToJournal(strCR+
                 "I endorsed "+
                 fParser.writeFormulaToString(root)+
                 writeShortValuation(),
                 !TConstants.HIGHLIGHT,
                 TConstants.TO_MARKER);
  placeMarker();




  /*
  WriteToJournal(concat(gCR, 'I endorsed '), FALSE, gTConstants.TO_MARKER);
  gOutputStr := '';
  WriteFormula(root);
  WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
  gOutputStr := '';
  WriteShortValuation;
  PlaceMarker;


  */

 public void iEndorse(TFormula root, ArrayList valuation){
   TFormula tempFormula,leftFormula,rightFormula;
   char freeCh,instantiation;

   if ((fShapePanel.getSemantics().universeEmpty())&&(root.termsInFormula()!=null)){
      writeToJournal(TConstants.fErrors1, TConstants.HIGHLIGHT,
          !TConstants.TO_MARKER);
      return;                     //error
      }

   String individuals = fShapePanel.getSemantics().getCurrentUniverse();  //non empty

   leftFormula=root.getLLink();
   rightFormula=root.getRLink();

   writeToJournal(strCR+
                  "I endorsed "+
                  fParser.writeFormulaAndWrap(root)+
                  writeShortValuation(),
                  !TConstants.HIGHLIGHT,
                  TConstants.TO_MARKER);
   placeMarker();

/*
     WriteToJournal(concat(gCR, 'I endorsed '), FALSE, gTConstants.TO_MARKER);
     gOutputStr := '';
     WriteFormula(root);
     WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
     gOutputStr := '';
     WriteShortValuation;
     PlaceMarker;

*/

  tempFormula=root.copyFormula();
  tempFormula.interpretFreeVariables(fValuation);

  //freeCh = tempFormula.firstFreeVar();
  
  freeCh = fParser.firstFreeVar(tempFormula);

  if (freeCh != chBlank) {
    if (fParser.addToValuation('?',freeCh,fValuation))
       ;

   writeToJournal(strCR +
                  "You should deny " +
                  fParser.writeFormulaAndWrap(root)+
                  writeShortValuation()+
                  strCR+
                  "for a ? that you choose. "
                  ,!TConstants.HIGHLIGHT,
                   TConstants.TO_MARKER);

   placeMarker();
   clearValuation();

 }

 /*
   tempFormula := root.CopyFormula;
  InterpretFreeVariables(tempFormula);
  if FirstVarFree(tempFormula, freeCh) then
   begin
    tempFormula.DismantleFormula;
    WriteToJournal(concat(gCR, 'You should deny '), FALSE, gTConstants.TO_MARKER);
    gOutputStr := '';
    WriteFormula(root);
    WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
    AddtoValuation('?', freeCh);
    WriteShortValuation;
    WriteToJournal(concat(gCR, 'for a ? that you choose. '), FALSE, gTConstants.TO_MARKER);
    PlaceMarker;
    fvaluation.DeleteAll; {this does not free objects, should do}
               {avoids leaving a question mark}

   end


 */

  else if((root.fKind == TFormula.predicator) ||
         (root.fKind == TFormula.equality)){
            Toolkit.getDefaultToolkit().beep();
            if (valuedFormulaTrue(root))
              writeToJournal(TConstants.fErrors7,!TConstants.HIGHLIGHT,TConstants.TO_MARKER);  //right answer
            else
              writeToJournal(TConstants.fErrors8,!TConstants.HIGHLIGHT,TConstants.TO_MARKER);  //right answer
  }
/*
         begin
        SysBeep(5);
        if ValuedFormulaTrue(root) then {atomic}
         WriteToJournal(gErrorsArray[7], FALSE, gTConstants.TO_MARKER) {right answer}
        else
         WriteToJournal(gErrorsArray[8], FALSE, gTConstants.TO_MARKER); {wrong answer}
       end


*/
else{
 switch (root.fKind){
   case TFormula.unary:
     iDeny(rightFormula,valuation);
     break;
     /*
            IDeny(rightFormula, valuation);

*/

   case TFormula.binary:

     if (fParser.isAnd(root)){
       writeToJournal(strCR +
        "You should deny " +
        fParser.writeFormulaAndWrap(leftFormula)+
        writeShortValuation()+
        strCR +
        "Or you should deny " +
        fParser.writeFormulaAndWrap(rightFormula)+
        writeShortValuation()
        ,!TConstants.HIGHLIGHT,
         TConstants.TO_MARKER);
       placeMarker();
     };


     /*        chAnd:
         begin
         WriteToJournal(concat(gCR, 'You should deny '), FALSE, gTConstants.TO_MARKER);
         gOutputStr := '';
         WriteFormula(leftFormula);
         WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
         WriteShortValuation;
         WriteToJournal(concat(gCR, 'Or you should deny '), FALSE, gTConstants.TO_MARKER);
         gOutputStr := '';
         WriteFormula(rightFormula);
         WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
         WriteShortValuation;
         PlaceMarker;
         end;

     */

     if (fParser.isOr(root)){
       if (valuedFormulaTrue(leftFormula))
         iEndorse(leftFormula,valuation);
       else
         iEndorse(rightFormula,valuation);
     };

     /*       if ValuedFormulaTrue(leftFormula) then

      IEndorse(leftFormula, valuation)

      else

      IEndorse(rightFormula, valuation);


*/

     if (fParser.isImplic(root)){
       if (valuedFormulaTrue(leftFormula))
         iEndorse(rightFormula,valuation);
       else
         iDeny(leftFormula,valuation);
     };


      /*
            chImplic:

              if ValuedFormulaTrue(leftFormula) then

              IEndorse(rightFormula, valuation)

              else

              IDeny(leftFormula, valuation);

     */

      if (fParser.isEquiv(root)){
        TFormula implicFormula =new TFormula(TFormula.binary,
                           String.valueOf(chImplic),
                           leftFormula,
                           rightFormula);
       TFormula reverseFormula =new TFormula(TFormula.binary,
                  String.valueOf(chImplic),
                  rightFormula,
                  leftFormula);


 writeToJournal(strCR +
        "You should deny " +
        fParser.writeFormulaAndWrap(implicFormula)+
        writeShortValuation()+
        strCR +
        "Or you should deny " +
        fParser.writeFormulaAndWrap(reverseFormula)+
        writeShortValuation()
        ,!TConstants.HIGHLIGHT,
         TConstants.TO_MARKER);
       placeMarker();


      }
      break;
/*
             chEquiv:
             begin
             WriteToJournal(concat(gCR, 'You should deny '), FALSE, gTConstants.TO_MARKER);
             root.fInfo[1] := chImplic;
             gOutputStr := '';
             WriteFormula(root);
             WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
             WriteShortValuation;
             tempFormula := root.fLlink;
             root.fLlink := root.fRlink;
             root.fRlink := tempFormula;
             tempFormula := nil;
             WriteToJournal(concat(gCR, 'Or you should deny '), FALSE, gTConstants.TO_MARKER);
             gOutputStr := '';
             WriteFormula(root);
             WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
             WriteShortValuation;
             PlaceMarker;
       end;

*/

  case TFormula.quantifier:
    if (fParser.isUniquant(root)){

         if (fParser.addToValuation('?',root.quantVar().charAt(0),fValuation))
            ;

  writeToJournal(strCR +
                 "You should deny " +
                 fParser.writeFormulaAndWrap(root.scope())+
                 writeShortValuation()+
                 strCR+
                 "for a ? that you choose. "
                 ,!TConstants.HIGHLIGHT,
                  TConstants.TO_MARKER);

  placeMarker();
  clearValuation();
      }
/*
             WriteToJournal(concat(gCR, 'You should deny '), FALSE, gTConstants.TO_MARKER);
             gOutputStr := '';
             WriteFormula(rightFormula);
             WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
             AddtoValuation('?', root.QuantVar);
             WriteShortValuation;
             WriteToJournal(concat(gCR, 'for a ? that you choose. '), FALSE, gTConstants.TO_MARKER);
             fvaluation.DeleteAll; {this does not free objects, should do}
                                    {avoids leaving a question mark}
             PlaceMarker;
             end;


*/

if (fParser.isExiquant(root)){
        tempFormula=root.copyFormula();
        tempFormula.interpretFreeVariables(fValuation);

        instantiation=exiQuantVerifier(tempFormula);

        if (instantiation==chBlank)
          instantiation=individuals.charAt(0);  //any will do

        if (fParser.addToValuation(instantiation,root.quantVar().charAt(0),fValuation))
       ;
     iEndorse(root.scope(),valuation);
      }
      /* chExiquant:
             begin

             tempFormula := root.CopyFormula; {check this next section}
             InterpretFreeVariables(tempFormula);

             if ExiquantTrue(tempFormula, instantiation) then
             ;
                                    {this primes instantiation with an instnat}

             tempFormula.DismantleFormula;

             AddtoValuation(instantiation, root.QuantVar); {this should value the}
      {                                   freech to the refuting instant}

             IEndorse(rightFormula, valuation);
             end;


      */

     if (fParser.isUnique(root)){
  TFormula expansion = root.expandUnique();
  if (expansion!=null)
    iEndorse(expansion,valuation);
}
break;
   case TFormula.typedQuantifier:

     TFormula expansion=null;

     if (fParser.isTypedUniquant(root))
       expansion=fParser.expandTypeUni(root);
     else
     if (fParser.isTypedExiquant(root))
       expansion=fParser.expandTypeExi(root);


   if (expansion==null) //should not happen
        iEndorse(expansion,valuation);

      break;
   default:
     ;
 }
}
}

   /*

 procedure TDeriverDocument.IEndorse (var root: TFormula; valuation: TList);

  var
   itsMainConnective, instantiation, freeCh: CHAR;
   itsTruth: BOOLEAN;
   tempFormula, leftFormula, rightFormula: TFormula;

  procedure PlaceMarker;

  begin
   WriteToJournal(chInsertMarker, FALSE, gTConstants.TO_MARKER);
  end;

 begin
  leftFormula := root.fLlink;
  rightFormula := root.fRlink;

  WriteToJournal(concat(gCR, 'I endorsed '), FALSE, gTConstants.TO_MARKER);
  gOutputStr := '';
  WriteFormula(root);
  WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
  gOutputStr := '';
  WriteShortValuation;
  PlaceMarker;

  tempFormula := root.CopyFormula;
  InterpretFreeVariables(tempFormula);
  if FirstVarFree(tempFormula, freeCh) then
   begin
    tempFormula.DismantleFormula;
    WriteToJournal(concat(gCR, 'You should deny '), FALSE, gTConstants.TO_MARKER);
    gOutputStr := '';
    WriteFormula(root);
    WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
    AddtoValuation('?', freeCh);
    WriteShortValuation;
    WriteToJournal(concat(gCR, 'for a ? that you choose. '), FALSE, gTConstants.TO_MARKER);
    PlaceMarker;
    fvaluation.DeleteAll; {this does not free objects, should do}
               {avoids leaving a question mark}

   end
  else

   begin
    tempFormula.DismantleFormula;

    if (root.fKind = predicator) or (root.fKind = equality) then
     begin
      SysBeep(5);
      if ValuedFormulaTrue(root) then {atomic}
       WriteToJournal(gErrorsArray[7], FALSE, gTConstants.TO_MARKER) {right answer}
      else
       WriteToJournal(gErrorsArray[8], FALSE, gTConstants.TO_MARKER); {wrong answer}
     end
    else
     begin
      itsMainConnective := root.fInfo[1];
      case itsMainConnective of

       chNeg:

       IDeny(rightFormula, valuation);

       chAnd:
       begin
       WriteToJournal(concat(gCR, 'You should deny '), FALSE, gTConstants.TO_MARKER);
       gOutputStr := '';
       WriteFormula(leftFormula);
       WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
       WriteShortValuation;
       WriteToJournal(concat(gCR, 'Or you should deny '), FALSE, gTConstants.TO_MARKER);
       gOutputStr := '';
       WriteFormula(rightFormula);
       WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
       WriteShortValuation;
       PlaceMarker;
       end;

       chOr:

       if ValuedFormulaTrue(leftFormula) then

       IEndorse(leftFormula, valuation)

       else

       IEndorse(rightFormula, valuation);

       chImplic:

       if ValuedFormulaTrue(leftFormula) then

       IEndorse(rightFormula, valuation)

       else

       IDeny(leftFormula, valuation);

       chEquiv:
       begin
       WriteToJournal(concat(gCR, 'You should deny '), FALSE, gTConstants.TO_MARKER);
       root.fInfo[1] := chImplic;
       gOutputStr := '';
       WriteFormula(root);
       WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
       WriteShortValuation;
       tempFormula := root.fLlink;
       root.fLlink := root.fRlink;
       root.fRlink := tempFormula;
       tempFormula := nil;
       WriteToJournal(concat(gCR, 'Or you should deny '), FALSE, gTConstants.TO_MARKER);
       gOutputStr := '';
       WriteFormula(root);
       WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
       WriteShortValuation;
       PlaceMarker;
       end;

       chUniquant:
       begin
       WriteToJournal(concat(gCR, 'You should deny '), FALSE, gTConstants.TO_MARKER);
       gOutputStr := '';
       WriteFormula(rightFormula);
       WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
       AddtoValuation('?', root.QuantVar);
       WriteShortValuation;
       WriteToJournal(concat(gCR, 'for a ? that you choose. '), FALSE, gTConstants.TO_MARKER);
       fvaluation.DeleteAll; {this does not free objects, should do}
                              {avoids leaving a question mark}
       PlaceMarker;
       end;

       chExiquant:
       begin

       tempFormula := root.CopyFormula; {check this next section}
       InterpretFreeVariables(tempFormula);

       if ExiquantTrue(tempFormula, instantiation) then
       ;
                              {this primes instantiation with an instnat}

       tempFormula.DismantleFormula;

       AddtoValuation(instantiation, root.QuantVar); {this should value the}
{                                   freech to the refuting instant}

       IEndorse(rightFormula, valuation);
       end;

       otherwise
      end;

     end;
   end;
 end;




*/



  public void youDeny(TFormula root, ArrayList valuation){
    TFormula tempFormula,leftFormula,rightFormula;
    char freeCh,instantiation;

    if ((fShapePanel.getSemantics().universeEmpty())&&(root.termsInFormula()!=null)){
       writeToJournal(TConstants.fErrors1, TConstants.HIGHLIGHT,
           !TConstants.TO_MARKER);
       return;                     //error
       }

    String individuals = fShapePanel.getSemantics().getCurrentUniverse();  //non empty

    leftFormula=root.getLLink();
    rightFormula=root.getRLink();

    writeToJournal(strCR+
                   "You denied "+
                   fParser.writeFormulaAndWrap(root)+
                   writeShortValuation(),
                   !TConstants.HIGHLIGHT,
                   TConstants.TO_MARKER);
    placeMarker();

    /*
         WriteToJournal(concat(gCR, 'You denied '), FALSE, gTConstants.TO_MARKER);
         gOutputStr := '';
         WriteFormula(root);
         WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
         gOutputStr := '';
         WriteShortValuation;
    PlaceMarker;
    */

         tempFormula=root.copyFormula();
         tempFormula.interpretFreeVariables(fValuation);

        // freeCh = tempFormula.firstFreeVar();
         
         freeCh = fParser.firstFreeVar(tempFormula);

if (freeCh != chBlank) {


         instantiation=freeVerifier(root,freeCh);

         if (instantiation==chBlank)
           instantiation=individuals.charAt(0);  //any will do

         if (fParser.addToValuation(instantiation,freeCh,fValuation))
        ;
      iEndorse(root,valuation);
}

   /*
    tempFormula := root.CopyFormula;
    InterpretFreeVariables(tempFormula);
    if FirstVarFree(tempFormula, freeCh) then
     begin
      if FreeTrue(tempFormula, freeCh, instantiation) then
       ;
      tempFormula.DismantleFormula;
      AddtoValuation(instantiation, freeCh);
                 { SubTermVar(root, instantiation, freeCh);}
      IEndorse(root, valuation)
    */

   else if((root.fKind == TFormula.predicator) ||
          (root.fKind == TFormula.equality)){
             Toolkit.getDefaultToolkit().beep();
             if (valuedFormulaTrue(root))
               writeToJournal(TConstants.fErrors6,!TConstants.HIGHLIGHT,TConstants.TO_MARKER);  //right answer
             else
               writeToJournal(TConstants.fErrors5,!TConstants.HIGHLIGHT,TConstants.TO_MARKER);  //right answer
   }
/*
         if (root.fKind = predicator) or (root.fKind = equality) then
          begin
           SysBeep(5);
           if ValuedFormulaTrue(root) then {atomic}
            WriteToJournal(gErrorsArray[6], FALSE, gTConstants.TO_MARKER) {wrong answer}

           else
            WriteToJournal(gErrorsArray[5], FALSE, gTConstants.TO_MARKER); {right answer}
       end end
    else
*/
else{
  switch (root.fKind){
    case TFormula.unary:
      writeToJournal(strCR +
               "You should endorse " +
               fParser.writeFormulaAndWrap(rightFormula)+
               writeShortValuation()
               ,!TConstants.HIGHLIGHT,
                TConstants.TO_MARKER);
      placeMarker();
      youEndorse(rightFormula,valuation);
      break;
      /*
         WriteToJournal(concat(gCR, 'You should endorse '), FALSE, gTConstants.TO_MARKER);{right}
  {                                   answer}
         gOutputStr := '';
         WriteFormula(rightFormula);
         WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
         WriteShortValuation;
         PlaceMarker;
         YouEndorse(rightFormula, valuation);
*/

    case TFormula.binary:
      if (fParser.isAnd(root)){
        writeToJournal(strCR +
         "You should deny " +
         fParser.writeFormulaAndWrap(leftFormula)+
         writeShortValuation()+
         strCR +
         "Or you should deny " +
         fParser.writeFormulaAndWrap(rightFormula)+
         writeShortValuation()
         ,!TConstants.HIGHLIGHT,
          TConstants.TO_MARKER);
        placeMarker();
      };


    /*         begin
             WriteToJournal(concat(gCR, 'You should deny '), FALSE, gTConstants.TO_MARKER);
             gOutputStr := '';
             WriteFormula(leftFormula);
             WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
             WriteShortValuation;
             WriteToJournal(concat(gCR, 'Or you should deny '), FALSE, gTConstants.TO_MARKER);
             gOutputStr := '';
             WriteFormula(rightFormula);
             WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
             WriteShortValuation;
             PlaceMarker;
             end;

      */

      if (fParser.isOr(root)){
        if (valuedFormulaTrue(leftFormula))
          iEndorse(leftFormula,valuation);
        else
          iEndorse(rightFormula,valuation);
      };

       /*         begin
         if ValuedFormulaTrue(leftFormula) then
         begin
         IEndorse(leftFormula, valuation);
         end
         else
         begin
         IEndorse(rightFormula, valuation);
         end;
         end;

*/

      if (fParser.isImplic(root)){
        if (valuedFormulaTrue(leftFormula))
          iEndorse(rightFormula,valuation);
        else
          iDeny(leftFormula,valuation);
      };


       /*
             begin
         if ValuedFormulaTrue(leftFormula) then
         begin
         IEndorse(rightFormula, valuation);
         end
         else
         begin
         IDeny(leftFormula, valuation);
         end;
         end;


      */

       if (fParser.isEquiv(root)){
         TFormula implicFormula =new TFormula(TFormula.binary,
                            String.valueOf(chImplic),
                            leftFormula,
                            rightFormula);
        TFormula reverseFormula =new TFormula(TFormula.binary,
                   String.valueOf(chImplic),
                   rightFormula,
                   leftFormula);


  writeToJournal(strCR +
         "You should deny " +
         fParser.writeFormulaAndWrap(implicFormula)+
         writeShortValuation()+
         strCR +
         "Or you should deny " +
         fParser.writeFormulaAndWrap(reverseFormula)+
         writeShortValuation()
         ,!TConstants.HIGHLIGHT,
          TConstants.TO_MARKER);
        placeMarker();


       }
       break;
/*
                WriteToJournal(concat(gCR, 'You should deny '), FALSE, gTConstants.TO_MARKER);
                root.fInfo[1] := chImplic;
                gOutputStr := '';
                WriteFormula(root);
                WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
                WriteShortValuation;
                tempFormula := root.fLlink;
                root.fLlink := root.fRlink;
                root.fRlink := tempFormula;
                tempFormula := nil;
                WriteToJournal(concat(gCR, 'Or you should deny '), FALSE, gTConstants.TO_MARKER);
                gOutputStr := '';
                WriteFormula(root);
                WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
                WriteShortValuation;
                PlaceMarker;
         end;
*/

   case TFormula.quantifier:
     if (fParser.isUniquant(root)){

          if (fParser.addToValuation('?',root.quantVar().charAt(0),fValuation))
             ;

   writeToJournal(strCR +
                  "You should deny " +
                  fParser.writeFormulaAndWrap(root.scope())+
                  writeShortValuation()+
                  strCR+
                  "for a ? that you choose. "
                  ,!TConstants.HIGHLIGHT,
                   TConstants.TO_MARKER);

   placeMarker();
   clearValuation();
       }


     /*         chUniquant:
              begin
              WriteToJournal(concat(gCR, 'You should deny '), FALSE, gTConstants.TO_MARKER);
              gOutputStr := '';
              WriteFormula(rightFormula);
              WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
              AddtoValuation('?', root.QuantVar);
              WriteShortValuation;
              WriteToJournal(concat(gCR, 'for a ? that you choose. '), FALSE, gTConstants.TO_MARKER);
              fvaluation.DeleteAll; {this does not free objects, should do}
                                     {avoids leaving a question mark}
              PlaceMarker;
              end;
 */
if (fParser.isExiquant(root)){
         tempFormula=root.copyFormula();
         tempFormula.interpretFreeVariables(fValuation);

         instantiation=exiQuantVerifier(tempFormula);

         if (instantiation==chBlank)
           instantiation=individuals.charAt(0);  //any will do

         if (fParser.addToValuation(instantiation,root.quantVar().charAt(0),fValuation))
        ;
      iEndorse(root.scope(),valuation);
       }
/*         chExiquant:
         begin
         tempFormula := root.CopyFormula; {check this next section}
         InterpretFreeVariables(tempFormula);

         if ExiquantTrue(tempFormula, instantiation) then
         ;
                                {this primes instantiation with an instnat}

         tempFormula.DismantleFormula;

         AddtoValuation(instantiation, root.QuantVar);

         IEndorse(rightFormula, valuation);

         end;

       */

      if (fParser.isUnique(root)){
  TFormula expansion = root.expandUnique();
  if (expansion!=null)
    youDeny(expansion,valuation);
}
break;
    case TFormula.typedQuantifier:

      TFormula expansion=null;

      if (fParser.isTypedUniquant(root))
        expansion=fParser.expandTypeUni(root);
      else
      if (fParser.isTypedExiquant(root))
        expansion=fParser.expandTypeExi(root);


    if (expansion==null) //should not happen
        youDeny(expansion,valuation);
    break;

    default:
      ;
  }
}
}


/*
    procedure TDeriverDocument.YouDeny (var root: TFormula; valuation: TList);

    var
     itsTruth: BOOLEAN;
     itsMainConnective, instantiation, freeCh: CHAR;
     tempFormula, leftFormula, rightFormula: TFormula;

    procedure PlaceMarker;

    begin
     WriteToJournal(chInsertMarker, FALSE, gTConstants.TO_MARKER);
    end;

   begin
    leftFormula := root.fLlink;
    rightFormula := root.fRlink;

    WriteToJournal(concat(gCR, 'You denied '), FALSE, gTConstants.TO_MARKER);
    gOutputStr := '';
    WriteFormula(root);
    WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
    gOutputStr := '';
    WriteShortValuation;
    PlaceMarker;

    tempFormula := root.CopyFormula;
    InterpretFreeVariables(tempFormula);
    if FirstVarFree(tempFormula, freeCh) then
     begin
      if FreeTrue(tempFormula, freeCh, instantiation) then
       ;
      tempFormula.DismantleFormula;
      AddtoValuation(instantiation, freeCh);
                 { SubTermVar(root, instantiation, freeCh);}
      IEndorse(root, valuation);
     end
    else
     begin
      tempFormula.DismantleFormula;

      if (root.fKind = predicator) or (root.fKind = equality) then
       begin
        SysBeep(5);
        if ValuedFormulaTrue(root) then {atomic}
         WriteToJournal(gErrorsArray[6], FALSE, gTConstants.TO_MARKER) {wrong answer}

        else
         WriteToJournal(gErrorsArray[5], FALSE, gTConstants.TO_MARKER); {right answer}
       end
      else
       begin
        itsMainConnective := root.fInfo[1];
        case itsMainConnective of

         chNeg:
         begin
         WriteToJournal(concat(gCR, 'You should endorse '), FALSE, gTConstants.TO_MARKER);{right}
  {                                   answer}
         gOutputStr := '';
         WriteFormula(rightFormula);
         WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
         WriteShortValuation;
         PlaceMarker;
         YouEndorse(rightFormula, valuation);

         end;

         chAnd:
         begin
         WriteToJournal(concat(gCR, 'You should deny '), FALSE, gTConstants.TO_MARKER);
         gOutputStr := '';
         WriteFormula(leftFormula);
         WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
         WriteShortValuation;
         WriteToJournal(concat(gCR, 'Or you should deny '), FALSE, gTConstants.TO_MARKER);
         gOutputStr := '';
         WriteFormula(rightFormula);
         WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
         WriteShortValuation;
         PlaceMarker;
         end;

         chOr:
         begin
         if ValuedFormulaTrue(leftFormula) then
         begin
         IEndorse(leftFormula, valuation);
         end
         else
         begin
         IEndorse(rightFormula, valuation);
         end;
         end;

         chImplic:
         begin
         if ValuedFormulaTrue(leftFormula) then
         begin
         IEndorse(rightFormula, valuation);
         end
         else
         begin
         IDeny(leftFormula, valuation);
         end;
         end;

         chEquiv:
         begin
         WriteToJournal(concat(gCR, 'You should deny '), FALSE, gTConstants.TO_MARKER);
         root.fInfo[1] := chImplic;
         gOutputStr := '';
         WriteFormula(root);
         WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
         WriteShortValuation;
         tempFormula := root.fLlink;
         root.fLlink := root.fRlink;
         root.fRlink := tempFormula;
         tempFormula := nil;
         WriteToJournal(concat(gCR, 'Or you should deny '), FALSE, gTConstants.TO_MARKER);
         gOutputStr := '';
         WriteFormula(root);
         WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
         WriteShortValuation;
         PlaceMarker;
         end;

         chUniquant:
         begin
         WriteToJournal(concat(gCR, 'You should deny '), FALSE, gTConstants.TO_MARKER);
         gOutputStr := '';
         WriteFormula(rightFormula);
         WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
         AddtoValuation('?', root.QuantVar);
         WriteShortValuation;
         WriteToJournal(concat(gCR, 'for a ? that you choose. '), FALSE, gTConstants.TO_MARKER);
         fvaluation.DeleteAll; {this does not free objects, should do}
                                {avoids leaving a question mark}
         PlaceMarker;
         end;

         chExiquant:
         begin
         tempFormula := root.CopyFormula; {check this next section}
         InterpretFreeVariables(tempFormula);

         if ExiquantTrue(tempFormula, instantiation) then
         ;
                                {this primes instantiation with an instnat}

         tempFormula.DismantleFormula;

         AddtoValuation(instantiation, root.QuantVar);

         IEndorse(rightFormula, valuation);

         end;

         otherwise
        end;

       end;
     end;
   end;


*/

  public void youEndorse(TFormula root, ArrayList valuation){
    TFormula tempFormula,leftFormula,rightFormula;
    char freeCh,instantiation;

    if ((fShapePanel.getSemantics().universeEmpty())&&(root.termsInFormula()!=null)){
   writeToJournal(TConstants.fErrors1, TConstants.HIGHLIGHT,
       !TConstants.TO_MARKER);
   return;                     //error
   }

String individuals = fShapePanel.getSemantics().getCurrentUniverse();  //non empty


    leftFormula=root.getLLink();
    rightFormula=root.getRLink();

    writeToJournal(strCR+
                   "You endorsed "+
                   fParser.writeFormulaAndWrap(root)+
                   writeShortValuation(),
                   !TConstants.HIGHLIGHT,
                   TConstants.TO_MARKER);
    placeMarker();

    /*
     WriteToJournal(concat(gCR, 'You endorsed '), FALSE, gTConstants.TO_MARKER);
       gOutputStr := '';
       WriteFormula(root);
       WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
       gOutputStr := '';
       WriteShortValuation;
      PlaceMarker;
    */

   tempFormula=root.copyFormula();
   tempFormula.interpretFreeVariables(fValuation);

  // freeCh = tempFormula.firstFreeVar();
   
   freeCh = fParser.firstFreeVar(tempFormula);

   if (freeCh != chBlank) {
     if (fParser.addToValuation('?',freeCh,fValuation))
        ;

      writeToJournal(strCR +
                     "You should endorse " +
                     fParser.writeFormulaAndWrap(root)+
                     writeShortValuation()+
                     strCR+
                     "for a ? that you choose. "
                     ,!TConstants.HIGHLIGHT,
                      TConstants.TO_MARKER);

      placeMarker();
      clearValuation(); // avoids leaving the question mark
  }
   /*
      tempFormula := root.CopyFormula;
  InterpretFreeVariables(tempFormula);
  if FirstVarFree(tempFormula, freeCh) then
   begin
    tempFormula.DismantleFormula;
    WriteToJournal(concat(gCR, 'You should endorse '), FALSE, gTConstants.TO_MARKER);
    gOutputStr := '';
    WriteFormula(root);
    WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
    AddtoValuation('?', freeCh);
    WriteShortValuation;
    WriteToJournal(concat(gCR, 'for a ? that you choose. '), FALSE, gTConstants.TO_MARKER);
    PlaceMarker;
    fvaluation.DeleteAll; {this does not free objects, should do}
               {avoids leaving a question mark}
   end
    */

   else if((root.fKind == TFormula.predicator) ||
          (root.fKind == TFormula.equality)){
             Toolkit.getDefaultToolkit().beep();
             if (valuedFormulaTrue(root))
               writeToJournal(TConstants.fErrors3,!TConstants.HIGHLIGHT,TConstants.TO_MARKER);  //right answer
             else
               writeToJournal(TConstants.fErrors4,!TConstants.HIGHLIGHT,TConstants.TO_MARKER);  //right answer
   }
/*
      begin
       tempFormula.DismantleFormula;
       if (root.fKind = predicator) or (root.fKind = equality) then
        begin
         SysBeep(5);
         if ValuedFormulaTrue(root) then {atomic}
          WriteToJournal(gErrorsArray[3], FALSE, gTConstants.TO_MARKER) {right answer}
         else
          WriteToJournal(gErrorsArray[4], FALSE, gTConstants.TO_MARKER); {wrong answer}
        end
    else
*/
else{
  switch (root.fKind){
    case TFormula.unary:
      writeToJournal(strCR +
               "You should deny " +
               fParser.writeFormulaAndWrap(rightFormula)+
               writeShortValuation()
               ,!TConstants.HIGHLIGHT,
                TConstants.TO_MARKER);
      placeMarker();
      youDeny(rightFormula,valuation);
      break;
      /*
       begin
       WriteToJournal(concat(gCR, 'You should deny '), FALSE, gTConstants.TO_MARKER);
       gOutputStr := '';
       WriteFormula(rightFormula);
       WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
       WriteShortValuation;
       PlaceMarker;

       YouDeny(rightFormula, valuation);
       end;
*/

    case TFormula.binary:
      if (fParser.isAnd(root)){
        if (valuedFormulaTrue(leftFormula))
          iDeny(rightFormula,valuation);
        else
          iDeny(leftFormula,valuation);
      };

      if (fParser.isOr(root)){
        writeToJournal(strCR +
         "You should endorse " +
         fParser.writeFormulaAndWrap(leftFormula)+
         writeShortValuation()+
         strCR +
         "Or you should endorse " +
         fParser.writeFormulaAndWrap(rightFormula)+
         writeShortValuation()
         ,!TConstants.HIGHLIGHT,
          TConstants.TO_MARKER);
        placeMarker();
      };


 /*      begin
      WriteToJournal(concat(gCR, 'You should endorse '), FALSE, gTConstants.TO_MARKER);
      gOutputStr := '';
      WriteFormula(leftFormula);
      WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
      WriteShortValuation;
      WriteToJournal(concat(gCR, 'Or you should endorse '), FALSE, gTConstants.TO_MARKER);
      gOutputStr := '';
      WriteFormula(rightFormula);
      WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
      WriteShortValuation;
      PlaceMarker;
      end;
 */


      if (fParser.isImplic(root)){
        writeToJournal(strCR +
         "You should deny " +
         fParser.writeFormulaAndWrap(leftFormula)+
         writeShortValuation()+
         strCR +
         "Or you should endorse " +
         fParser.writeFormulaAndWrap(rightFormula)+
         writeShortValuation()
         ,!TConstants.HIGHLIGHT,
          TConstants.TO_MARKER);
        placeMarker();
      };


       /*
             begin
       WriteToJournal(concat(gCR, 'You should deny '), FALSE, gTConstants.TO_MARKER);
       gOutputStr := '';
       WriteFormula(leftFormula);
       WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
       WriteShortValuation;
       WriteToJournal(concat(gCR, 'Or you should endorse '), FALSE, gTConstants.TO_MARKER);
       gOutputStr := '';
       WriteFormula(rightFormula);
       WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
       WriteShortValuation;
       PlaceMarker;
       end;

      */

      if (fParser.isEquiv(root)){
        TFormula implicFormula;
       if ((valuedFormulaTrue(leftFormula))&&
           !(valuedFormulaTrue(rightFormula))){
         implicFormula=new TFormula(TFormula.binary,
                                    String.valueOf(chImplic),
                                    leftFormula,
                                    rightFormula);
         iDeny(implicFormula,valuation);
       }
       else{
         implicFormula=new TFormula(TFormula.binary,
                                    String.valueOf(chImplic),
                                    rightFormula,
                                    leftFormula);
         iDeny(implicFormula,valuation);
       }

     };
     break;


/*
              begin
              if (ValuedFormulaTrue(leftFormula) and not ValuedFormulaTrue(rightFormula)) then
              begin
              root.fInfo[1] := chImplic;
              IDeny(root, valuation);
              end
              else
              begin
              tempFormula := root.fLlink;
              root.fLlink := root.fRlink;
              root.fRlink := tempFormula;
              tempFormula := nil;
              root.fInfo[1] := chImplic;
              IDeny(root, valuation);
              end;
       end;

*/

   case TFormula.quantifier:
     if ((fShapePanel.getSemantics().universeEmpty())&&(root.termsInFormula()!=null)){
        writeToJournal(TConstants.fErrors1, TConstants.HIGHLIGHT,
               !TConstants.TO_MARKER);
       return;
        }

       if (fParser.isUniquant(root)){
         tempFormula=root.copyFormula();
         tempFormula.interpretFreeVariables(fValuation);

         instantiation=uniQuantFalsifier(tempFormula);

         if (instantiation==chBlank)
           instantiation=individuals.charAt(0);  //any will do

         if (fParser.addToValuation(instantiation,root.quantVar().charAt(0),fValuation))
        ;
      iDeny(root.scope(),valuation);
       }

       /*chUniquant:
             begin
             tempFormula := root.CopyFormula; {check this next section}
             InterpretFreeVariables(tempFormula);

             if UniquantTrue(tempFormula, instantiation) then
             ;
                                    {this primes instantiation with an instnat}

             tempFormula.DismantleFormula;

             AddtoValuation(instantiation, root.QuantVar);

             IDeny(rightFormula, valuation);
             end;

       */

       if (fParser.isExiquant(root)){

          if (fParser.addToValuation('?',root.quantVar().charAt(0),fValuation))
             ;

   writeToJournal(strCR +
                  "You should endorse " +
                  fParser.writeFormulaAndWrap(root.scope())+
                  writeShortValuation()+
                  strCR+
                  "for a ? that you choose. "
                  ,!TConstants.HIGHLIGHT,
                   TConstants.TO_MARKER);

   placeMarker();
   clearValuation();
       }
/*       chExiquant:
begin
WriteToJournal(concat(gCR, 'You should endorse '), FALSE, gTConstants.TO_MARKER);
gOutputStr := '';
WriteFormula(rightFormula);
WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
AddtoValuation('?', root.QuantVar);
WriteShortValuation;
WriteToJournal(concat(gCR, 'for a ? that you choose. '), FALSE, gTConstants.TO_MARKER);
fvaluation.DeleteAll; {this does not free objects, should do}
                       {avoids leaving a question mark}
PlaceMarker;
end;

*/

      if (fParser.isUnique(root)){
        TFormula expansion = root.expandUnique();
        if (expansion!=null)
          youEndorse(expansion,valuation);
       }
      break;

     case TFormula.typedQuantifier:

     TFormula expansion=null;

     if (fParser.isTypedUniquant(root))
       expansion=fParser.expandTypeUni(root);
     else
     if (fParser.isTypedExiquant(root))
       expansion=fParser.expandTypeExi(root);


   if (expansion==null) //should not happen
      youEndorse(expansion,valuation);
    break;


    default:
      ;
  }


}

}

 /*

 procedure TDeriverDocument.YouEndorse (var root: TFormula; valuation: TList);

  var
   itsTruth: BOOLEAN;
   itsMainConnective, instantiation, freeCh: CHAR;
   tempFormula, leftFormula, rightFormula: TFormula;

  procedure PlaceMarker;

  begin
   WriteToJournal(chInsertMarker, FALSE, gTConstants.TO_MARKER);
  end;

 begin
  leftFormula := root.fLlink;
  rightFormula := root.fRlink;

  WriteToJournal(concat(gCR, 'You endorsed '), FALSE, gTConstants.TO_MARKER);
  gOutputStr := '';
  WriteFormula(root);
  WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
  gOutputStr := '';
  WriteShortValuation;
  PlaceMarker;

  tempFormula := root.CopyFormula;
  InterpretFreeVariables(tempFormula);
  if FirstVarFree(tempFormula, freeCh) then
   begin
    tempFormula.DismantleFormula;
    WriteToJournal(concat(gCR, 'You should endorse '), FALSE, gTConstants.TO_MARKER);
    gOutputStr := '';
    WriteFormula(root);
    WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
    AddtoValuation('?', freeCh);
    WriteShortValuation;
    WriteToJournal(concat(gCR, 'for a ? that you choose. '), FALSE, gTConstants.TO_MARKER);
    PlaceMarker;
    fvaluation.DeleteAll; {this does not free objects, should do}
               {avoids leaving a question mark}
   end
  else
   begin
    tempFormula.DismantleFormula;
    if (root.fKind = predicator) or (root.fKind = equality) then
     begin
      SysBeep(5);
      if ValuedFormulaTrue(root) then {atomic}
       WriteToJournal(gErrorsArray[3], FALSE, gTConstants.TO_MARKER) {right answer}
      else
       WriteToJournal(gErrorsArray[4], FALSE, gTConstants.TO_MARKER); {wrong answer}
     end
    else
     begin
      itsMainConnective := root.fInfo[1];
      case itsMainConnective of

       chNeg:
       begin
       WriteToJournal(concat(gCR, 'You should deny '), FALSE, gTConstants.TO_MARKER);
       gOutputStr := '';
       WriteFormula(rightFormula);
       WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
       WriteShortValuation;
       PlaceMarker;

       YouDeny(rightFormula, valuation);
       end;

       chAnd:
       begin
       if ValuedFormulaTrue(leftFormula) then
       begin
       IDeny(rightFormula, valuation);
       end
       else
       begin
       IDeny(leftFormula, valuation);
       end;
       end;

       chOr:
       begin
       WriteToJournal(concat(gCR, 'You should endorse '), FALSE, gTConstants.TO_MARKER);
       gOutputStr := '';
       WriteFormula(leftFormula);
       WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
       WriteShortValuation;
       WriteToJournal(concat(gCR, 'Or you should endorse '), FALSE, gTConstants.TO_MARKER);
       gOutputStr := '';
       WriteFormula(rightFormula);
       WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
       WriteShortValuation;
       PlaceMarker;
       end;

       chImplic:
       begin
       WriteToJournal(concat(gCR, 'You should deny '), FALSE, gTConstants.TO_MARKER);
       gOutputStr := '';
       WriteFormula(leftFormula);
       WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
       WriteShortValuation;
       WriteToJournal(concat(gCR, 'Or you should endorse '), FALSE, gTConstants.TO_MARKER);
       gOutputStr := '';
       WriteFormula(rightFormula);
       WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
       WriteShortValuation;
       PlaceMarker;
       end;

       chEquiv:
       begin
       if (ValuedFormulaTrue(leftFormula) and not ValuedFormulaTrue(rightFormula)) then
       begin
       root.fInfo[1] := chImplic;
       IDeny(root, valuation);
       end
       else
       begin
       tempFormula := root.fLlink;
       root.fLlink := root.fRlink;
       root.fRlink := tempFormula;
       tempFormula := nil;
       root.fInfo[1] := chImplic;
       IDeny(root, valuation);
       end;
       end;

       chUniquant:
       begin
       tempFormula := root.CopyFormula; {check this next section}
       InterpretFreeVariables(tempFormula);

       if UniquantTrue(tempFormula, instantiation) then
       ;
                              {this primes instantiation with an instnat}

       tempFormula.DismantleFormula;

       AddtoValuation(instantiation, root.QuantVar);

       IDeny(rightFormula, valuation);
       end;

       chExiquant:
       begin
       WriteToJournal(concat(gCR, 'You should endorse '), FALSE, gTConstants.TO_MARKER);
       gOutputStr := '';
       WriteFormula(rightFormula);
       WriteToJournal(gOutputStr, FALSE, gTConstants.TO_MARKER);
       AddtoValuation('?', root.QuantVar);
       WriteShortValuation;
       WriteToJournal(concat(gCR, 'for a ? that you choose. '), FALSE, gTConstants.TO_MARKER);
       fvaluation.DeleteAll; {this does not free objects, should do}
                              {avoids leaving a question mark}
       PlaceMarker;
       end;

       otherwise
      end;

     end;
   end;

 end;


   */



/************************** Endorse Deny ********************************************/






/************************** End of Endorse Deny ************************************/



}



/*

              {*******************   TDeriverDocument   ******************************}

  TDeriverDocument = object(TDocument)

 {each document has two windows and three views:- a pallette view,}
{ and a drawing view in the drawing window, a}
{ text view in the journal, and some controls in the journal. In addition,}
{ there sometimes is a help window and view which belongs to the appliaction as a whole}

    fDrawShapeView: TShapeView; {for drawing window}
    fDrawPaletteView: TPalette; {palette view in drawing window}

    fProofWindow: TProofWindow;  {and coerce}
                        {fProofTextList: TProofListView;  the proof window has its own texlistfield}
    fHeadFromFile: TList; {awkward because data is stored in fields}
{                                                            of proof window}
    fTailFromFile: TList; {and reading from disk is done before the}
{                                                            window is created}
    fProofTypeFromFile: ProofType; {these are used as temps}

    fJournalText: Handle; {MF Journal Text}
    fJournalTEView: TTEView; {MF A text view in Journal}
    fJournalWindow: TJournalWindow;

    fParser: TParser; {this serves to provide a type for reading and writing routines}

    fJournalFont: boolean; {format info, T is large}
    fProofFont: boolean;
    fRightMargin: INTEGER;

    fShapeList: TList;

    fCurrentUniverse: STR255;
    fCurrentProperties: array['A'..'Z'] of STR255;
    fCurrentRelations: array['A'..'Z'] of STR255;
    fCurrentFunctions: array['a'..'z'] of STR255;
    fCurrentIdentities: array['a'..'z'] of CHAR;

    fCurrentPropositions: array['A'..'Z'] of boolean;

    fValuation: TList; {the valuation to be used for terms}

    fDocState: DocState;
    fReopening: boolean;

    fReplaceCommand: TShapeReplaceCommand;




          {Tells us what the current replace}
{           command is (Cut, Paste).  NIL}
{           means there is no current replace}
{           command.}
    fFiltering: boolean; {Tells us whether shapes that are}
{                                                           'wasSelected' are not to be drawn if}
{                                                           gLastCmdDone is TRUE}


                                            {Initialize and Free in inc2.p}
    procedure TDeriverDocument.IShapeDocument (fileType: OSType);
    procedure TDeriverDocument.CreateInterpretationBoard; {a special}
{                                          shape}
    procedure TDeriverDocument.InitInterpretationArray;
    procedure TDeriverDocument.Free;
    OVERRIDE;
    procedure TDeriverDocument.FreeData;
    OVERRIDE;

                            {Overrides of basic TDocument methods for Display and Filing in Inc2..p}

    procedure TDeriverDocument.DoMakeViews (forPrinting: boolean);
    OVERRIDE;
    function TDeriverDocument.DoMenuCommand (aCmdNumber: CmdNumber): TCommand;
    OVERRIDE;
                                     {Handle interp and val commands}
    procedure TDeriverDocument.DoSetupMenus;
    OVERRIDE;
                                     {Arm the menu items handled by DoMenuCommand}

    procedure TDeriverDocument.DoNeedDiskSpace (var dataForkBytes, rsrcForkBytes: LONGINT);
    OVERRIDE;
    procedure TDeriverDocument.DoRead (aRefNum: INTEGER; rsrcExists, forPrinting: boolean);
    OVERRIDE;
    procedure TDeriverDocument.DoWrite (aRefNum: INTEGER; makingCopy: boolean);
    OVERRIDE;

                                     {ShapeList Routines }

                                     {Adding/deleting shapes}
    procedure TDeriverDocument.AddShape (shape: TShape);
    procedure TDeriverDocument.DeleteShape (shape: TShape);

                                     {Enumeration of shapes}
  {NB:  EachShapeDo iterates through the list of shapes.}
{     EachPotentialShape iterates through all the shapes in document}
{       plus any 'pastee' shapes which may have been added by a}
{     not-yet-committed PASTE.}
{     EachVirtualShape iterates through only those shapes that appear}
{       to be present at the moment to the USER , given the}
{     UNDO/REDO status of the last command.  Thus it iterates}
{     through some but possibly not all of the the shapes in the}
{     document, and possibly also through not-yet-in-the-document}
{     pastees}
    procedure TDeriverDocument.EachShapeDo (procedure DoThis (shape: TShape));
    procedure TDeriverDocument.EachPotentialShapeDo (procedure DoThis (shape: TShape));
    procedure TDeriverDocument.EachVirtualShapeDo (procedure DoThis (shape: TShape));
    function TDeriverDocument.FirstSelectedShapeThat (function TestSelectedShape (


       aShape: TShape): boolean): TShape;

    procedure TDeriverDocument.SurveyShapes (selecteesOnly: boolean; var numberOfShapes: INTEGER; var combinedExtent: Rect);

                                     {logic routines}

    function TDeriverDocument.FirstTermAvail: CHAR;
    function TDeriverDocument.DocumentValid (withoutSelectees: boolean): boolean;
    function TDeriverDocument.IdentityValid (withoutSelectees: BOOLEAN; thisShape: TShape): BOOLEAN;
    function TDeriverDocument.IndividualValid (withoutSelectees: boolean; thisShape: TShape): boolean;
                                                        (*override this to get the different constant term sets*)


    function TDeriverDocument.PropertyValid (withoutSelectees: boolean; itsName: CHAR; itsExtentRect: Rect): boolean;
    function TDeriverDocument.RelationValid (withoutSelectees: boolean; itsFrom, itsTo: POINT): boolean;
    function TDeriverDocument.TermAlreadyThere (thisterm: CHAR): boolean;

{$IFC introToDeriver}

{$ELSEC  }

                              {argument game}
    procedure TDeriverDocument.IDeny (var root: TFormula; valuation: TList);
    procedure TDeriverDocument.IEndorse (var root: TFormula; valuation: TList);
    procedure TDeriverDocument.YouDeny (var root: TFormula; valuation: TList);
    procedure TDeriverDocument.YouEndorse (var root: TFormula; valuation: TList);

{$ENDC  }

                                     {semantics}

    function TDeriverDocument.AtomicFormulaTrue (root: TFormula): boolean;
    function TDeriverDocument.EqualityTrue (root: TFormula): BOOLEAN;
    function TDeriverDocument.ExiquantTrue (root: TFormula; var individual: CHAR): boolean;
    function TDeriverDocument.FormulaTrue (root: TFormula): boolean;{call}
{                                          this rarely-- prefer valuedFormulatrue}
    function TDeriverDocument.FreeTrue (root: TFormula; freeCh: CHAR; var individual: CHAR): boolean;
    function TDeriverDocument.FreeFalse (root: TFormula; freeCh: CHAR; var individual: CHAR): boolean;
    function TDeriverDocument.PropertyTrue (property: CHAR; term: TFormula): boolean;
    function TDeriverDocument.RelationTrue (relation: CHAR; term1, term2: TFormula): boolean;
    function TDeriverDocument.ReferenceOK (root: TFormula; var notRefTo: CHAR): boolean;
    function TDeriverDocument.UniquantTrue (root: TFormula; var individual: CHAR): boolean;
    function TDeriverDocument.UniverseEmpty: boolean;
    function TDeriverDocument.ValuedFormulaTrue (root: TFormula): boolean;

                                                                (******currentfunction accessor*************)

    function TDeriverDocument.FindFunctionValue (funname, argument: CHAR): CHAR;
    function TDeriverDocument.ValueFunctionalTerm (term: TFormula): CHAR;


                                     {misc}
    procedure TDeriverDocument.AddtoValuation (instantiation, variable: CHAR);


    function TDeriverDocument.FirstVarFree (root: TFormula; var ch: char): BOOLEAN;
    function TDeriverDocument.FormulasConstants (root: TFormula): str255;


    function TDeriverDocument.InterpretationChanged: boolean;
    procedure TDeriverDocument.InterpretFreeVariables (var root: TFormula);
    procedure TDeriverDocument.WriteFormula (root: TFormula);
    procedure TDeriverDocument.WriteToJournal (message: STR255; TConstants.HIGHLIGHT: boolean; TConstants.TO_MARKER: boolean);
    procedure TDeriverDocument.WriteInterpretation;
    procedure TDeriverDocument.WriteTruePropositions;
    procedure TDeriverDocument.WriteShortValuation;
    procedure TDeriverDocument.WriteValuation;

                                     {Debugging in inc1.p}
                                     {$IFC qDebug}

    procedure TDeriverDocument.Fields (procedure DoToField (fieldName: STR255; fieldAddr: Ptr; fieldType: INTEGER));
    OVERRIDE;
                                     {$ENDC}

   end;



*/
